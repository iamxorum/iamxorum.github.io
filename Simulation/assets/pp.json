[
  {
    "id": 1,
    "question": "Ãn care dintre variantele de mai jos se declarÄƒ un tablou unidimensional (vector) ğ‘¥ Ã®n care se pot memora cel mult 100 de numere reale?",
    "answers": [
      "<div class=\"code_2\">x=float[100];</div>",
      "<div class=\"code_2\">double x[100];</div>",
      "<div class=\"code_2\">float x[100];</div>",
      "<div class=\"code_2\">real x(100);</div>"
    ],
    "correctAnswerIndexes": [1, 2],
    "details": "<p>\u00cen limbajul de programare C, un tablou unidimensional (vector) \u00een care se pot memora cel mult 100 de numere reale se declar\u0103 corect folosind urm\u0103toarele variante:</p>\n<ul>\n<li>b) <code>double x[100];</code></li>\n<li>c) <code>float x[100];</code></li>\n</ul>\n<p><strong>Explica\u021bie:</strong></p>\n<ul>\n<li><code>double x[100];</code> declar\u0103 un vector de 100 de elemente de tip <code>double</code>, care reprezint\u0103 numere reale pe 64 de bi\u021bi.</li>\n<li><code>float x[100];</code> declar\u0103 un vector de 100 de elemente de tip <code>float</code>, care reprezint\u0103 numere reale pe 32 de bi\u021bi.</li>\n</ul>\n<p>Celelalte op\u021biuni nu sunt corecte \u00een limbajul C:</p>\n<ul>\n<li>a) <code>x=float[100];</code> nu este o sintax\u0103 corect\u0103 \u00een C.</li>\n<li>d) <code>real x(100);</code> nu este o sintax\u0103 corect\u0103 \u00een C.</li>\n</ul>"
  },
  {
    "id": 2,
    "question": "Care dintre urmÄƒtoarele expresii logice este adevÄƒratÄƒ (are o valoare nenulÄƒ) dacÄƒ ÅŸi numai dacÄƒ numÄƒrul real memorat Ã®n variabila ğ‘¥ nu aparÅ£ine intervalului (0,5]?",
    "answers": [
      "<div class=\"code_2\">(x&lt;=0)||(x&gt;5)</div>",
      "<div class=\"code_2\">(x&lt;=0)&&(x&gt;5)</div>",
      "<div class=\"code_2\">(x&lt;0)||(x&gt;=5)</div>",
      "<div class=\"code_2\">(x&lt;=0)&&(x&gt;5)</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) (x<=0)||(x>5)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Intervalul (0,5] \u00eenseamn\u0103 c\u0103 \ud835\udc65 trebuie s\u0103 fie mai mare dec\u00e2t 0 \u0219i mai mic sau egal cu 5.</li>\n<li>Pentru ca \ud835\udc65 s\u0103 nu apar\u021bin\u0103 acestui interval, \ud835\udc65 trebuie s\u0103 fie fie mai mic sau egal cu 0 (<code>x<=0</code>), fie mai mare dec\u00e2t 5 (<code>x>5</code>).</li>\n<li>Combina\u021bia logic\u0103 <code>(x<=0)||(x>5)</code> este adev\u0103rat\u0103 doar atunci c\u00e2nd \ud835\udc65 nu apar\u021bine intervalului (0,5].</li>\n</ul>"
  },
  {
    "id": 3,
    "question": "Care dintre urmÄƒtoarele expresii este adevÄƒratÄƒ (are o valoare nenulÄƒ) dacÄƒ ÅŸi numai dacÄƒ numÄƒrul Ã®ntreg memorat Ã®n variabila ğ‘¥ aparÅ£ine intervalului (1,6]?",
    "answers": [
      "<div class=\"code_2\">(x&gt;=1)||(x&lt;6)</div>",
      "<div class=\"code_2\">(x&gt;1)||(x&lt;=6)</div>",
      "<div class=\"code_2\">(x&gt;1)&&(x&lt;6)</div>",
      "<div class=\"code_2\">(x&gt;1)&&(x&lt;=6)</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) (x>1)&&(x<=6)</strong></p>\n<p>Expresia corect\u0103 este <code>(x>1)&&(x<=6)</code> deoarece:</p>\n<ul>\n<li>Intervalul (1,6] \u00eenseamn\u0103 c\u0103 \ud835\udc65 trebuie s\u0103 fie mai mare dec\u00e2t 1 \u0219i mai mic sau egal cu 6.</li>\n<li>Expresia <code>(x>1)</code> verific\u0103 dac\u0103 \ud835\udc65 este mai mare dec\u00e2t 1.</li>\n<li>Expresia <code>(x<=6)</code> verific\u0103 dac\u0103 \ud835\udc65 este mai mic sau egal cu 6.</li>\n<li>Astfel, expresia <code>(x>1)&&(x<=6)</code> este adev\u0103rat\u0103 doar atunci c\u00e2nd \ud835\udc65 apar\u021bine intervalului (1,6].</li>\n</ul>"
  },
  {
    "id": 4,
    "question": "DupÄƒ executarea instrucÈ›iunii float x = 27/5*2/3*7; ce valoare va fi memoratÄƒ Ã®n variabila ğ‘¥?",
    "answers": ["25.2", "21", "6.3", "7"],
    "correctAnswerIndexes": [1],
    "details": "<p>Dup\u0103 executarea instruc\u021biunii <code>float x = 27/5*2/3*7;</code> valoarea memorat\u0103 \u00een variabila \ud835\udc65 va fi 21 deoarece:</p>\n<ul>\n<li>Opera\u021biile se efectueaz\u0103 conform ordinii de preceden\u021b\u0103 \u0219i cu tipuri de date implicite (\u00een acest caz, \u00eentregi).</li>\n<li><code>27 / 5</code> se evalueaz\u0103 ca 5 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>5 * 2</code> se evalueaz\u0103 ca 10.</li>\n<li><code>10 / 3</code> se evalueaz\u0103 ca 3 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>3 * 7</code> se evalueaz\u0103 ca 21.</li>\n<li>Rezultatul final este 21, care este apoi convertit la <code>float</code> \u0219i stocat \u00een variabila <code>x</code>.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>b) 21</strong></p>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float x = 27 / 5 * 2 / 3 * 7;  // Instruc\u021biunea dat\u0103\n    printf(\"x = %f\\n\", x);         // Afi\u0219eaz\u0103 valoarea lui x\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 5,
    "question": "DupÄƒ executarea instrucÈ›iunii float x = 55/17*5/8+48/5/8*15; ce valoare va fi memoratÄƒ Ã®n variabila ğ‘¥?",
    "answers": ["17.022058", "17", "16", "21.219914"],
    "correctAnswerIndexes": [2],
    "details": "<p>Dup\u0103 executarea instruc\u021biunii <code>float x = 55/17*5/8+48/5/8*15;</code> valoarea memorat\u0103 \u00een variabila \ud835\udc65 va fi **16.0** deoarece:</p>\n<ul>\n<li>Opera\u021biile se efectueaz\u0103 conform ordinii de preceden\u021b\u0103 \u0219i cu tipuri de date implicite (\u00een acest caz, \u00eentregi).</li>\n<li><code>55 / 17</code> se evalueaz\u0103 ca 3 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>3 * 5</code> se evalueaz\u0103 ca 15.</li>\n<li><code>15 / 8</code> se evalueaz\u0103 ca 1 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>48 / 5</code> se evalueaz\u0103 ca 9 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>9 / 8</code> se evalueaz\u0103 ca 1 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>1 * 15</code> se evalueaz\u0103 ca 15.</li>\n<li><code>1 + 15</code> se evalueaz\u0103 ca 16.</li>\n<li>Deoarece variabila \ud835\udc65 este de tip float, rezultatul 16 este convertit implicit la 16.0 \u0219i stocat \u00een variabila <code>x</code>.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>c) 16</strong></p>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float x = 55 / 17 * 5 / 8 + 48 / 5 / 8 * 15;  // Instruc\u021biunea dat\u0103\n    printf(\"x = %f\\n\", x);         // Afi\u0219eaz\u0103 valoarea lui x\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 6,
    "question": "Se considerÄƒ urmÄƒtoarea secvenÅ£Äƒ de instrucÈ›iuni:<br><br><div class=\"code\">int t=0,a=1234,b=10;<br>while(a&gt;=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div><br><br>Ce valori vor fi afiÈ™ate pe ecran dupÄƒ executarea secvenÈ›ei de mai sus?",
    "answers": ["124 4", "123 4", "123 5", "124 3"],
    "correctAnswerIndexes": [1],
    "details": "<p>Valorile afi\u0219ate pe ecran vor fi <b>123 4</b>.</p>\n<p>Explica\u021bie:</p>\n<ul>\n<li>Ini\u021bial, <code>t = 0</code>, <code>a = 1234</code> \u0219i <code>b = 10</code>.</li>\n<li>Ciclul <code>while</code> se execut\u0103 c\u00e2t timp <code>a</code> este mai mare sau egal cu <code>b</code>.</li>\n<li>La fiecare itera\u021bie:\n<ul>\n<li><code>a</code> este decrementat cu valoarea lui <code>b</code> (<code>a = a - b</code>).</li>\n<li><code>t</code> este incrementat cu 1 (<code>t++</code>).</li>\n</ul>\n</li>\n<li>Ciclul se opre\u0219te c\u00e2nd <code>a</code> devine mai mic dec\u00e2t <code>b</code>.</li>\n<li>Dup\u0103 executarea ciclului, valorile finale sunt <code>t = 123</code> \u0219i <code>a = 4</code>.</li>\n<li>Instruc\u021biunea <code>printf</code> afi\u0219eaz\u0103 aceste valori separate prin spa\u021biu.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>b) 123 4</strong></p>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int t = 0, a = 1234, b = 10;\n    while (a >= b) {\n        a = a - b;\n        t++;\n    }\n    printf(\"%d %d\\n\", t, a);\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 7,
    "question": "Care dintre urmÄƒtoarele secvenÅ£e de instrucÅ£iuni afiÅŸeazÄƒ valoarea 654, ÅŸtiind cÄƒ ğ‘  ÅŸi ğ‘– sunt douÄƒ variabile de tip Ã®ntreg?",
    "answers": [
      "<div class=\"code_2\">s=0;<br>for(i=0;i&lt;=654;i++) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">s=651;<br>while(s&lt;=654) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">for(i=1;i&lt;=3;i++) printf(\"%d\",7-i);</div>",
      "<div class=\"code_2\">s=7;<br>while(s&gt;=1) printf(\"%d\",s-1);</div>"
    ],
    "correctAnswerIndexes": [2],
    "details": "<p>R\u0103spuns corect: <strong>c) for(i=1;i<=3;i++) printf(\"%d\",7-i);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Secven\u021ba <code>for(i=1;i<=3;i++) printf(\"%d\",7-i);</code> afi\u0219eaz\u0103 valorile 6, 5 \u0219i 4, concaten\u00e2ndu-le \u00een 654.</li>\n<li>Variabila <code>i</code> ia valorile de la 1 la 3.</li>\n<li>La fiecare itera\u021bie, se afi\u0219eaz\u0103 <code>7-i</code>, astfel rezult\u00e2nd 6, 5 \u0219i 4.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i;\n    for(i = 1; i <= 3; i++) {\n        printf(\"%d\", 7 - i);\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 8,
    "question": "Care dintre urmÄƒtoarele secvenÅ£e de instrucÅ£iuni afiÅŸeazÄƒ valoarea 5432, ÅŸtiind cÄƒ ğ‘  ÅŸi ğ‘– sunt douÄƒ variabile de tip Ã®ntreg?",
    "answers": [
      "<div class=\"code_2\">s=0;<br>for(i=0;i&lt;=5432;i++) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">s=5421;<br>while(s&lt;=5432) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">for(i=1;i&lt;4;i++) printf(\"%d\",6-i);</div>",
      "<div class=\"code_2\">s=6;<br>while(s&gt;=3) printf(\"%d\",--s);</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) s=6;<br>while(s>=3) printf(\"%d\",--s);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, <code>s</code> este setat\u0103 la 6.</li>\n<li>\u00cen fiecare itera\u021bie a buclei <code>while</code>, valoarea lui <code>s</code> este decrementat\u0103 cu 1 \u00eenainte de a fi afi\u0219at\u0103.</li>\n<li>Buclele \u0219i afi\u0219\u0103rile sunt: 5, 4, 3 \u0219i astfel rezult\u0103 afi\u0219area valorii concatenat\u0103 5432.</li>\n<li>Decrementarea cu operatorul prefix <code>--s</code> asigur\u0103 c\u0103 valoarea lui <code>s</code> este redus\u0103 \u00eenainte de a fi folosit\u0103 \u00een <code>printf</code>.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int s = 6;\n    while(s >= 3) {\n        printf(\"%d\", --s);\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 9,
    "question": "ConsiderÄƒm urmÄƒtoarea secvenÅ£Äƒ de instrucÈ›iuni:<br><br><div class=\"code\">s = 1;<br>while(n>0) {<br><span class=\"tab\"></span>if(n%10>s) s=n%10;<br><span class=\"tab\"></span>else s=10;<br><span class=\"tab\"></span>n=n/10;<br>}<br>printf(\"%d\",s);</div><br><br>Åtiind cÄƒ variabilele ğ‘  ÅŸi ğ‘› sunt de tip Ã®ntreg, ce valoare se va afiÅŸa dupÄƒ executarea secvenÅ£ei de mai sus pentru ğ‘› = 9321?",
    "answers": ["9", "10", "15", "1"],
    "correctAnswerIndexes": [1],
    "details":"Observatii_Prof:Greseala principala consta in faptul ca variabila s nu este initializata. Daca s = 0 atunci secventa va afisa valoarea 9 (cifra maxima), altfel va afisa valoarea 10. In concluzie, va rog sa adaugati <b>initializarea s = 1</b> si raspunsul corect va ramane cel marcat acum (10)<span style='color: red;'>Atentie!!! In grile pdf raspunsul corect este b) 10</span><br>Pas cu pas pentru <i>n = 9321</i>:<br><br><b>Prima iterare:</b><ul><li><i>n = 9321</i></li><li><i>n % 10 = 1</i></li><li><i>s = 1</i></li><li><i>1 <= 1</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 932</i></li></ul><b>A doua iterare:</b><ul><li><i>n = 932</i></li><li><i>n % 10 = 2</i></li><li><i>s = 10</i></li><li><i>2 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 93</i></li></ul><b>A treia iterare:</b><ul><li><i>n = 93</i></li><li><i>n % 10 = 3</i></li><li><i>s = 10</i></li><li><i>3 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 9</i></li></ul><b>A patra iterare:</b><ul><li><i>n = 9</i></li><li><i>n % 10 = 9</i></li><li><i>s = 10</i></li><li><i>9 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 0</i></li></ul><br>La final, <i>n = 0</i> \u0219i ie\u0219im din bucl\u0103. Variabila <i>s</i> are valoarea 10.<br><br>Deci valoarea afi\u0219at\u0103 va fi:<br><br>b) 10\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int s = 1; // Ini\u021bializare conform observa\u021biilor profesorului\n    int n = 9321;\n\n    while(n > 0) {\n        if(n % 10 > s) s = n % 10;\n        else s = 10;\n        n = n / 10;\n    }\n\n    printf(\"%d\", s);\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 10,
    "question": "Care dintre urmÄƒtoarele secvenÅ£e de instrucÈ›iuni afiÅŸeazÄƒ cÃ¢tul ÅŸi restul Ã®mpÄƒrÅ£irii numÄƒrului natural ğ‘ la numÄƒrul natural nenul ğ‘?",
    "answers": [
      "<div class=\"code_2\">int t=0;<br>while(a&gt;=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div>",
      "<div class=\"code_2\">int t=0;<br>do {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>} while(a&gt;=b);<br>printf(\"%d %d\",t,a);</div>",
      "<div class=\"code_2\">int t=0;<br>while(a!=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,b);</div>",
      "<div class=\"code_2\">int t=0;<br>while(a%b==0) {<br><span class=\"tab\"></span>a=a-b;<span class=\"tab\"></span><br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "Observatie_Nelu: se pare ca a) si b) au acelasi rezultat.<p>R\u0103spuns corect: <strong>a) int t=0;<br>while(a>=b)<br>{<br>a=a-b;<br>t++;<br>}<br>printf(\"%d %d\",t,a);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Secven\u021ba de instruc\u021biuni \u00een varianta a) realizeaz\u0103 \u00eemp\u0103r\u021birea repetat\u0103 a lui <code>a</code> la <code>b</code> prin sc\u0103deri succesive.</li>\n<li>Variabila <code>t</code> num\u0103r\u0103 de c\u00e2te ori <code>b</code> a fost sc\u0103zut din <code>a</code>, reprezent\u00e2nd astfel c\u00e2tul \u00eemp\u0103r\u021birii.</li>\n<li>La finalul buclei, <code>a</code> con\u021bine restul \u00eemp\u0103r\u021birii.</li>\n<li>Instruc\u021biunea <code>printf(\"%d %d\",t,a);</code> afi\u0219eaz\u0103 c\u00e2tul \u0219i restul \u00eemp\u0103r\u021birii.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 1234; // Exemplu valoare pentru a\n    int b = 10;   // Exemplu valoare pentru b\n    int t = 0;\n    while(a >= b) {\n        a = a - b;\n        t++;\n    }\n    printf(\"%d %d\", t, a);\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 11,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(int a, int *b) {<br><span class=\"tab\"></span>int aux;<br><span class=\"tab\"></span>aux = a;<br><span class=\"tab\"></span>a = *b;<br><span class=\"tab\"></span>*b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x = 1,y = 2;<br><span class=\"tab\"></span>sch(x,&y);<br><span class=\"tab\"></span>printf(\"%d\",x+y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valoare se va afiÅŸa pe ecran dupÄƒ executarea programului de mai sus?<br>",
    "answers": ["2", "1", "4", "3"],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) 2</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: o valoare \u00eentreag\u0103 <code>a</code> \u0219i un pointer la un \u00eentreg <code>*b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre <code>a</code> \u0219i valoarea indicat\u0103 de pointerul <code>*b</code>. Aceasta \u00eenseamn\u0103 c\u0103 valoarea lui <code>x</code> r\u0103m\u00e2ne neschimbat\u0103, dar valoarea lui <code>y</code> este actualizat\u0103 cu valoarea lui <code>x</code>.</li>\n<li>Ini\u021bial, <code>x = 1</code> \u0219i <code>y = 2</code>. Dup\u0103 apelul func\u021biei <code>sch(x,&y);</code>, <code>x</code> r\u0103m\u00e2ne 1 \u0219i <code>y</code> devine 1.</li>\n<li>Prin urmare, valoarea lui <code>x + y</code> va fi <code>1 + 1 = 2</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d\", x + y);</code> afi\u0219eaz\u0103 valoarea 2.</li>\n</ul>"
  },
  {
    "id": 12,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(char a, char *b) {<br><span class=\"tab\"></span>char aux;<br><span class=\"tab\"></span>aux = a;<br><span class=\"tab\"></span>a = *b;<br><span class=\"tab\"></span>*b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>char x = '1',y = '2';<br><span class=\"tab\"></span>sch(x,&y);<br><span class=\"tab\"></span>printf(\"%c,%c\",x,y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori se vor afiÅŸa pe ecran dupÄƒ executarea programului de mai sus?<br>",
    "answers": ["1,2", "2,1", "1,1", "2,2"],
    "correctAnswerIndexes": [2],
    "details":
      "<p>R\u0103spuns corect: <strong>a) 1,1</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: o valoare de tip <code>char</code> <code>a</code> \u0219i un pointer la un <code>char</code> <code>*b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre <code>a</code> \u0219i valoarea indicat\u0103 de pointerul <code>*b</code>. Aceasta \u00eenseamn\u0103 c\u0103 valoarea lui <code>a</code> devine valoarea lui <code>*b</code> \u0219i invers.</li>\n<li>Totu\u0219i, schimbarea valorii lui <code>a</code> nu afecteaz\u0103 valoarea lui <code>x</code> \u00een func\u021bia <code>main</code> deoarece <code>a</code> este o variabil\u0103 local\u0103 a func\u021biei <code>sch</code>.</li>\n<li>Astfel, doar valoarea indicat\u0103 de <code>*b</code>, adic\u0103 <code>y</code>, va fi schimbat\u0103 cu valoarea ini\u021bial\u0103 a lui <code>x</code>.</li>\n<li>Ini\u021bial, <code>x = '1'</code> \u0219i <code>y = '2'</code>. Dup\u0103 apelul func\u021biei <code>sch(x,&y);</code>, <code>x</code> r\u0103m\u00e2ne '1' \u0219i <code>y</code> devine '1'.</li>\n<li>Prin urmare, valoarea afi\u0219at\u0103 va fi <code>1,1</code>.</li>\n</ul>"

  },
  {
    "id": 13,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(int *a, int b) {<br><span class=\"tab\"></span>int aux;<br><span class=\"tab\"></span>aux = *a;<br><span class=\"tab\"></span>*a = b;<br><span class=\"tab\"></span>b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x = 1,y = 2;<br><span class=\"tab\"></span>sch(&x,y);<br><span class=\"tab\"></span>printf(\"%d\",x*y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valoare se va afiÅŸa pe ecran dupÄƒ executarea programului de mai sus?<br>",
    "answers": ["3", "2", "4", "1"],
    "correctAnswerIndexes": [2],
    "details":
    "<p>R\u0103spuns corect: <strong>c) 4</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: un pointer la un \u00eentreg <code>*a</code> \u0219i un \u00eentreg <code>b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre variabila indicat\u0103 de pointerul <code>*a</code> \u0219i valoarea lui <code>b</code>.</li>\n<li>Ini\u021bial, <code>x = 1</code> \u0219i <code>y = 2</code>. La apelul func\u021biei <code>sch(&x, y);</code>, valoarea lui <code>*a</code> (adic\u0103 <code>x</code>) devine valoarea lui <code>b</code>, care este 2.</li>\n<li>Totu\u0219i, schimbarea valorii lui <code>b</code> \u00een func\u021bia <code>sch</code> nu afecteaz\u0103 valoarea lui <code>y</code> \u00een func\u021bia <code>main</code> deoarece <code>b</code> este o variabil\u0103 local\u0103 a func\u021biei <code>sch</code>.</li>\n<li>Dup\u0103 apelul func\u021biei, <code>x</code> devine 2 \u0219i <code>y</code> r\u0103m\u00e2ne 2.</li>\n<li>Prin urmare, valoarea lui <code>x * y</code> va fi <code>2 * 2 = 4</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d\", x * y);</code> afi\u0219eaz\u0103 valoarea 4.</li>\n</ul>"

  },
  {
    "id": 14,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void f(int a,int *b) {<br><span class=\"tab\"></span>a++;<br><span class=\"tab\"></span>*b=a;<br><span class=\"tab\"></span>(*b)++;<br>}<br><br>void g(int *a,int b) {<br><span class=\"tab\"></span>b++;<br><span class=\"tab\"></span>*a=b;<br><span class=\"tab\"></span>(*a)++;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x=4, y=-2;<br><span class=\"tab\"></span>f(x,&y);<br><span class=\"tab\"></span>g(&x,y);<br><span class=\"tab\"></span>printf(\"%d %d\",x,y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori se vor afiÅŸa pe ecran dupÄƒ executarea programului de mai sus?<br>",
    "answers": ["4 8", "8 8", "8 6", "6 6"],
    "correctAnswerIndexes": [2],
    "details":
      "<p>R\u0103spuns corect: <strong>c) 8 6</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>\u00cen func\u021bia <code>f</code>, <code>a</code> este incrementat, devenind 5. Apoi, valoarea lui <code>a</code> (5) este atribuit\u0103 variabilei indicate de <code>*b</code> (adic\u0103 <code>y</code>), deci <code>y</code> devine 5. \u00cen final, <code>(*b)++</code> incrementeaz\u0103 valoarea lui <code>y</code>, care devine 6.</li>\n<li>Deci, dup\u0103 apelul <code>f(x, &y)</code>, valorile sunt: <code>x = 4</code>, <code>y = 6</code>.</li>\n<li>\u00cen func\u021bia <code>g</code>, <code>b</code> este incrementat, devenind 7. Apoi, valoarea lui <code>b</code> (7) este atribuit\u0103 variabilei indicate de <code>*a</code> (adic\u0103 <code>x</code>), deci <code>x</code> devine 7. \u00cen final, <code>(*a)++</code> incrementeaz\u0103 valoarea lui <code>x</code>, care devine 8.</li>\n<li>Deci, dup\u0103 apelul <code>g(&x, y)</code>, valorile sunt: <code>x = 8</code>, <code>y = 6</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d %d\", x, y);</code> afi\u0219eaz\u0103 valorile 8 \u0219i 6.</li>\n</ul>"

  },
  {
    "id": 15,
    "question": "Care dintre urmÄƒtoarele secvenÅ£e de instrucÅ£iuni atribuie variabilei de tip Ã®ntreg ğ‘šğ‘ğ‘¥ cea mai mare valoare din tabloul ğ‘, format din ğ‘› numere Ã®ntregi?<br>",
    "answers": [
      "<div class=\"code_2\">max=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;max) max=a[i];</div>",
      "<div class=\"code_2\">max=a[0];<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;a[i+1]) max=a[i];</div>",
      "<div class=\"code_2\">max=a[0];<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;max) max=a[i];</div>",
      "<div class=\"code_2\">max=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&lt;a[i+1]) max=a[i+1];</div>"
    ],
    "correctAnswerIndexes": [2],
    "details":
      "<p>Explicarea fiec\u0103rei op\u021biuni:<ol type=\"a\"><li>Aceast\u0103 secven\u021b\u0103 va func\u021biona corect doar dac\u0103 toate elementele din tabloul a sunt pozitive. \u00cen cazul \u00een care toate valorile sunt negative sau exist\u0103 valori negative care sunt mai mici dec\u00e2t zero (valoarea ini\u021bial\u0103 a max), atunci rezultatul va fi incorect, deoarece nicio valoare negativ\u0103 nu va fi mai mare dec\u00e2t 0.</li><li>Aceast\u0103 secven\u021b\u0103 este incorect\u0103 deoarece compara\u021bi fiecare element a[i] cu elementul urm\u0103tor a[i+1], \u0219i atribui\u021bi lui max valoarea a[i] doar dac\u0103 aceasta este mai mare dec\u00e2t a[i+1]. Acest algoritm nu garanteaz\u0103 g\u0103sirea celei mai mari valori din tablou, ci efectueaz\u0103 o verificare gre\u0219it\u0103 \u00eentre elementele consecutive.</li><li>Aceast\u0103 secven\u021b\u0103 \u00eencepe prin a seta max la prima valoare din tablou \u0219i apoi verific\u0103 fiecare element din tablou. Dac\u0103 un element a[i] este mai mare dec\u00e2t max curent, atunci max este actualizat cu acea valoare. Aceasta este metoda corect\u0103 de a determina cea mai mare valoare dintr-un tablou.</li><li>Aceast\u0103 secven\u021b\u0103 este incorect\u0103, deoarece compara\u021bia \u0219i atribuirea se fac \u00eentre elementele consecutive \u0219i max este setat la valoarea urm\u0103toare a[i+1] doar dac\u0103 este mai mare dec\u00e2t a[i]. Acesta nu este un mod adecvat de a g\u0103si maximul \u00eentr-un tablou, deoarece max nu va fi neap\u0103rat cea mai mare valoare din \u00eentregul tablou, ci doar \u00eentre perechile consecutive.</li></ol><p>R\u0103spuns corect: <strong>c) max=a[0];<br>for(i=0;i&lt;n;i++)<br>if(a[i]&gt;max) max=a[i];</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bializarea variabilei <code>max</code> cu prima valoare a tabloului <code>a[0]</code> asigur\u0103 c\u0103 orice valoare din tablou va fi comparat\u0103 corect.</li>\n<li>Buclele parcurg toate elementele tabloului de la 0 la <code>n-1</code>.</li>\n<li>Dac\u0103 elementul curent <code>a[i]</code> este mai mare dec\u00e2t valoarea curent\u0103 a lui <code>max</code>, atunci <code>max</code> este actualizat la <code>a[i]</code>.</li>\n<li>La finalul buclei, <code>max</code> va con\u021bine cea mai mare valoare din tablou.</li>\n</ul>\n<p>Exemplu de rulare pas cu pas:</p>\n<ol>\n<li>S\u0103 presupunem c\u0103 avem tabloul <code>a = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]</code> \u0219i <code>n = 11</code>.</li>\n<li>Ini\u021bial, <code>max = a[0] = 3</code>.</li>\n<li>Itera\u021biile buclei:</li>\n<ul>\n<li><code>i=0</code>, <code>a[0]=3</code>, <code>max=3</code> (nu se schimb\u0103)</li>\n<li><code>i=1</code>, <code>a[1]=1</code>, <code>max=3</code> (nu se schimb\u0103)</li>\n<li><code>i=2</code>, <code>a[2]=4</code>, <code>max=4</code> (se schimb\u0103)</li>\n<li><code>i=3</code>, <code>a[3]=1</code>, <code>max=4</code> (nu se schimb\u0103)</li>\n<li><code>i=4</code>, <code>a[4]=5</code>, <code>max=5</code> (se schimb\u0103)</li>\n<li><code>i=5</code>, <code>a[5]=9</code>, <code>max=9</code> (se schimb\u0103)</li>\n<li><code>i=6</code>, <code>a[6]=2</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=7</code>, <code>a[7]=6</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=8</code>, <code>a[8]=5</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=9</code>, <code>a[9]=3</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=10</code>, <code>a[10]=5</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n</ul>\n<li>La finalul buclei, <code>max</code> r\u0103m\u00e2ne 9, care este cea mai mare valoare din tablou.</li>\n</ol>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i, n, max;\n\n    // Citirea valorii lui n\n    printf(\"Introduce\u021bi num\u0103rul de elemente: \");\n    scanf(\"%d\", &n);\n\n    int a[n];  // Alocarea unui array de dimensiune n\n\n    // Citirea valorilor \u00een array-ul a\n    printf(\"Introduce\u021bi elementele: \\n\");\n    for(i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n    }\n    // Ini\u021bializarea lui max cu primul element din array\n    // si \u00cencepem de la 1 deoarece max este deja ini\u021bializat cu a[0]\n    max=a[0];\n    for(i=0;i&lt;n;i++)\n        if(a[i]&gt;max) max=a[i];\n\n    printf(\"Valoarea maxim\u0103 este: %d\\n\", max);\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 16,
    "question": "<div class=\"code\">np=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(â€¦) np++;<br>printf(\"%d\",np);</div><br><br>Cu ce expresie dintre cele de mai jos trebuie Ã®nlocuite spaÅ£iile punctate din secvenÅ£Äƒ de instrucÈ›iuni datÄƒ astfel Ã®ncÃ¢t aceasta sÄƒ afiÅŸeze cÃ¢te valori strict pozitive ÅŸi pare sunt Ã®n tabloul ğ‘, format din ğ‘› numere Ã®ntregi?<br>",
    "answers": [
      "<div class=\"code_2\">(a[i]&gt;0)&&(a[i]%2!=0)</div>",
      "<div class=\"code_2\">(a[i]&gt;0)&&(a[i]%2==0)</div>",
      "<div class=\"code_2\">(a[i]&gt;0)||(a[i]%2!=0)</div>",
      "<div class=\"code_2\">(a[i]&gt;=0)||(a[i]%2==0)</div>"
    ],
    "correctAnswerIndexes": [1],
    "details":
      "<p>R\u0103spuns corect: <strong>b) (a[i]>0)&&(a[i]%2==0)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Expresia <code>(a[i]>0)</code> verific\u0103 dac\u0103 elementul din tablou este strict pozitiv.</li>\n<li>Expresia <code>(a[i]%2==0)</code> verific\u0103 dac\u0103 elementul din tablou este par.</li>\n<li>Combina\u021bia logic\u0103 <code>(a[i]>0)&&(a[i]%2==0)</code> asigur\u0103 c\u0103 elementul este at\u00e2t pozitiv, c\u00e2t \u0219i par.</li>\n<li>Astfel, variabila <code>np</code> va fi incrementat\u0103 doar pentru elementele strict pozitive \u0219i pare.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i, n, np = 0;\n\n    // Citirea valorii lui n\n    printf(\"Introduce\u021bi num\u0103rul de elemente: \");\n    scanf(\"%d\", &n);\n\n    int a[n];  // Alocarea unui array de dimensiune n\n\n    // Citirea valorilor \u00een array-ul a\n    printf(\"Introduce\u021bi elementele: \\n\");\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Num\u0103rarea valorilor strict pozitive \u0219i pare\n    for(i = 0; i < n; i++) {\n        if((a[i]>0) && (a[i]%2==0)) {\n            np++;\n        }\n    }\n\n    // Afi\u0219area rezultatului\n    printf(\"Num\u0103rul de elemente strict pozitive \u0219i pare: %d\\n\", np);\n    return 0;\n}\n</code></pre>"
 
  },
  {
    "id": 17,
    "question": "Care este valoarea expresiei?<br><br><div class=\"code\">strlen(\"programare\")+strcmp(\"test\",\"test\")</div><br><br>",
    "answers": ["10", "14", "18", "\"programaretesttest\""],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) 10</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>strlen(\"programare\")</code> calculeaz\u0103 lungimea \u0219irului de caractere \"programare\". Lungimea acestui \u0219ir este 10 caractere.</li>\n<li>Func\u021bia <code>strcmp(\"test\", \"test\")</code> compar\u0103 cele dou\u0103 \u0219iruri de caractere \"test\" \u0219i \"test\". Deoarece cele dou\u0103 \u0219iruri sunt identice, <code>strcmp</code> va returna 0.</li>\n<li>Prin urmare, valoarea expresiei <code>strlen(\"programare\") + strcmp(\"test\", \"test\")</code> va fi <code>10 + 0</code>, adic\u0103 10.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int result;\n    result = strlen(\"programare\") + strcmp(\"test\", \"test\");\n    printf(\"%d\\n\", result);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 18,
    "question": "<div class=\"code\">char s[100];<br>strcpy(s,\"\");<br>strcat(s,\"abcdefgh\");<br>strcpy(s+2,s+4);<br>printf(\"%s %d\" ,s,strlen(s));</div><br><br>Ce se va afiÅŸa pe ecran dupÄƒ executarea secvenÅ£ei date?<br>",
    "answers": ["adefgh 6", "abefgh 6", "abfgh 5", "abefgh 8"],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) abefgh 6</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este declarat cu 100 de caractere.</li>\n<li><code>strcpy(s, \"\");</code> ini\u021bializeaz\u0103 \u0219irul <code>s</code> cu \u0219irul vid.</li>\n<li><code>strcat(s, \"abcdefgh\");</code> concateneaz\u0103 \u0219irul \"abcdefgh\" la \u0219irul <code>s</code>, rezult\u00e2nd <code>s = \"abcdefgh\"</code>.</li>\n<li><code>strcpy(s+2, s+4);</code> copiaz\u0103 \u0219irul \u00eencep\u00e2nd de la indexul 4 (care este \"e\") la indexul 2, rezult\u00e2nd <code>s = \"abefgh\"</code>.</li>\n<li>\u00cen final, <code>printf(\"%s %d\", s, strlen(s));</code> afi\u0219eaz\u0103 \u0219irul <code>s</code> \u0219i lungimea acestuia.</li>\n<li>Lungimea \u0219irului <code>abefgh</code> este 6.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[100];\n    strcpy(s, \"\");\n    strcat(s, \"abcdefgh\");\n    strcpy(s+2, s+4);\n\t//Conversia valorii returnate de strlen la int pentru eliminarea avertiz\u0103rilor\n    printf(\"%s %d\\n\", s, (int)strlen(s));  // Afi\u0219eaz\u0103 \u0219irul \u0219i lungimea acestuia\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 19,
    "question": "Care din urmÄƒtoarele expresii de tip logic este adevÄƒratÄƒ (are o valoare nenulÄƒ) dacÄƒ ÅŸi numai dacÄƒ ÅŸirul de caractere ğ‘ , de lungime 10, este obÅ£inut prin concatenarea a douÄƒ ÅŸiruri identice?<br>",
    "answers": [
      "<div class=\"code_2\">strcmp(s,s+5)==0</div>",
      "<div class=\"code_2\">s==strstr(s,s+5)</div>",
      "<div class=\"code_2\">s==s+5</div>",
      "<div class=\"code_2\">strcmp(s,strcat(s,s+5))==0</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) s==strstr(s,s+5)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>strstr(s, s+5)</code> caut\u0103 \u0219irul <code>s+5</code> \u00een \u0219irul <code>s</code>.</li>\n<li>Dac\u0103 \u0219irul <code>s+5</code> este g\u0103sit \u00een \u0219irul <code>s</code>, atunci func\u021bia va returna un pointer la loca\u021bia unde \u0219irul a fost g\u0103sit.</li>\n<li>Dac\u0103 cele dou\u0103 \u0219iruri sunt identice, atunci pointerul returnat va fi egal cu pointerul c\u0103tre \u0219irul <code>s</code>.</li>\n<li>Prin urmare, expresia <code>s == strstr(s, s+5)</code> va fi adev\u0103rat\u0103 doar dac\u0103 \u0219irul <code>s</code> este ob\u021binut prin concatenarea a dou\u0103 \u0219iruri identice.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[10];\n    // Ini\u021bializarea \u0219irului s\n    strcpy(s, \"testtest\");\n\n    // Verificarea dac\u0103 s este ob\u021binut prin concatenarea a dou\u0103 \u0219iruri identice\n    if(s == strstr(s, s+5)) {\n        printf(\"Adev\u0103rat\");\n    } else {\n        printf(\"Fals\");\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 20,
    "question": "ConsiderÄƒm urmÄƒtoarea secvenÅ£Äƒ de instrucÈ›iuni:<br><br><div class=\"code\">char s[]=\"abcdabcd\",c = 'c';<br>char *p = strchr(s,c);<br>printf(\"%d\",p - s);</div><br><br>Ce se va afiÅŸa pe ecran dupÄƒ executarea secvenÅ£ei date?<br>",
    "answers": ["cdabcd", "6", "cd", "2"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) 2</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code> \u0219i caracterul <code>c</code> este definit ca <code>'c'</code>.</li>\n<li>Func\u021bia <code>strchr(s, c)</code> caut\u0103 prima apari\u021bie a caracterului <code>c</code> \u00een \u0219irul <code>s</code>.</li>\n<li>Dac\u0103 caracterul este g\u0103sit, func\u021bia returneaz\u0103 un pointer la loca\u021bia caracterului \u00een \u0219irul <code>s</code>.</li>\n<li>Deoarece caracterul <code>'c'</code> este g\u0103sit la indexul 2 \u00een \u0219irul <code>s</code>, pointerul <code>p</code> va con\u021bine adresa acestui caracter.</li>\n<li>Prin urmare, diferen\u021ba dintre pointerul <code>p</code> \u0219i pointerul c\u0103tre \u0219irul <code>s</code> va fi 2, deoarece caracterul <code>'c'</code> se afl\u0103 la indexul 2 \u00een \u0219irul <code>s</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[] = \"abcdabcd\", c = 'c';\n    char *p = strchr(s, c);\n    printf(\"%d\", p - s);  // Afi\u0219eaz\u0103 diferen\u021ba dintre pointeri\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 21,
    "question": "ConsiderÄƒm urmÄƒtoarea secvenÅ£Äƒ de instrucÈ›iuni:<br><br><div class=\"code\">char s[20];<br>strcpy(s,\"abcdabcd\");<br>strncat(s,s+2,3);<br>strcpy(s,s+4);<br>printf(\"%d\",strlen(s));</div><br><br>Ce se va afiÅŸa pe ecran dupÄƒ executarea secvenÅ£ei date?<br>",
    "answers": ["6", "10", "9", "7"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) 7</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code>.</li>\n<li><code>strncat(s, s+2, 3)</code> concateneaz\u0103 primele 3 caractere de la indexul 2 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdabcdab\"</code>.</li>\n<li><code>strcpy(s, s+4)</code> copiaz\u0103 \u0219irul de la indexul 4 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdabcdababcd\"</code>.</li>\n<li>Prin urmare, lungimea \u0219irului <code>s</code> va fi 7, deoarece con\u021bine 7 caractere.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[20];\n    strcpy(s, \"abcdabcd\");\n    strncat(s, s+2, 3);\n    strcpy(s, s+4);\n    printf(\"%d\", strlen(s));  // Afi\u0219eaz\u0103 lungimea \u0219irului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 22,
    "question": "ConsiderÄƒm urmÄƒtoarea secvenÅ£Äƒ de instrucÈ›iuni:<br><br><div class=\"code\">char s[20];<br>strncpy(s,\"abcdabcd\",6);<br>s[6]='\\0';<br>strcat(s,s+4);<br>strcpy(s+3,s+6);<br>printf(\"%s\",s);</div><br><br>Ce se va afiÅŸa pe ecran dupÄƒ executarea secvenÅ£ei date?<br>",
    "answers": ["abcabab", "abcdab", "abcab", "abcdabd"],
    "correctAnswerIndexes": [2],
    "details": "<p>R\u0103spuns corect: <strong>c) abcab</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code>.</li>\n<li><code>strncpy(s, \"abcdabcd\", 6)</code> copiaz\u0103 primele 6 caractere din \u0219irul <code>\"abcdabcd\"</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdab\"</code>.</li>\n<li><code>s[6] = '\\0'</code> adaug\u0103 terminatorul de \u0219ir la indexul 6, astfel \u00eencÃ¢t \u0219irul <code>s</code> s\u0103 aib\u0103 o lungime de 6 caractere.</li>\n<li><code>strcat(s, s+4)</code> concateneaz\u0103 \u0219irul de la indexul 4 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcab\"</code>.</li>\n<li><code>strcpy(s+3, s+6)</code> copiaz\u0103 \u0219irul de la indexul 6 din <code>s</code> la indexul 3 din <code>s</code>. \u0218irul rezultat va fi <code>\"abcab\"</code>.</li>\n<li>Prin urmare, \u0219irul rezultat va fi <code>\"abcab\"</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[20];\n    strncpy(s, \"abcdabcd\", 6);\n    s[6] = '\\0';\n    strcat(s, s+4); // Concatenarea \u0219irului de la indexul 4\n    strcpy(s+3, s+6);  // Copierea \u0219irului de la indexul 6 la indexul 3\n    printf(\"%s\", s);  // Afi\u0219eaz\u0103 \u0219irul rezultat\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 23,
    "question": "ConsiderÄƒm urmÄƒtoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int zi,luna,an;<br>}Data;<br><br>typedef struct {<br><span class=\"tab\"></span>char nume[30];<br><span class=\"tab\"></span>Data data_nasterii;<br><span class=\"tab\"></span>float media;<br>}Student;</div><br><br>È˜tiind cÄƒ variabila st este de tip Student, indicaÈ›i instrucÅ£iunea de mai jos prin care luna<br>naÅŸterii studentului respectiv primeÈ™te valoarea 12:<br>",
    "answers": [
      "<div class=\"code_2\">st-&gt;data_nasterii-&gt;luna=12;</div>",
      "<div class=\"code_2\">st.data_nasterii.luna=12;</div>",
      "<div class=\"code_2\">data_nasterii.luna=12;</div>",
      "<div class=\"code_2\">st.luna=12;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) st.data_nasterii.luna=12</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>st</code> este de tip <code>Student</code>, trebuie s\u0103 acces\u0103m campul <code>luna</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>st->data_nasterii->luna=12;</code> este incorect\u0103 deoarece <code>st</code> este o variabil\u0103 de tip <code>Student</code>, nu un pointer c\u0103tre <code>Student</code>. Accesarea cu <code>-></code> este incorect\u0103 \u00een acest context.</li>\n<li><strong>Op\u021biunea b)</strong> <code>st.data_nasterii.luna=12;</code> este corect\u0103 deoarece acceseaz\u0103 direct campul <code>luna</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>data_nasterii.luna=12;</code> este incorect\u0103 deoarece <code>data_nasterii</code> nu este o variabil\u0103 accesibil\u0103 direct, ci un camp al variabilei <code>st</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>st.luna=12;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze un camp <code>luna</code> care nu exist\u0103 direct \u00een structura <code>Student</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n\nint main() {\n    Student st;\n    st.data_nasterii.luna = 12;\n    printf(\"Luna nasterii: %d\\n\", st.data_nasterii.luna);  // Afi\u0219eaz\u0103 luna na\u0219terii\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 24,
    "question": "ConsiderÄƒm urmÄƒtoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int zi,luna,an;<br>}Data;<br><br>typedef struct {<br><span class=\"tab\"></span>char nume[30];<br><span class=\"tab\"></span>Data data_nasterii;<br><span class=\"tab\"></span>float media;<br>}Student;</div><br><br>È˜tiind cÄƒ variabila st este de tip Student, indicaÈ›i instrucÅ£iunea de mai jos prin care anul<br>naÅŸterii studentului respectiv primeÈ™te valoarea 1990:<br>",
    "answers": [
      "<div class=\"code_2\">st-&gt;data_nasterii-&gt;an=1990;</div>",
      "<div class=\"code_2\">st.data_nasterii.an=1990;</div>",
      "<div class=\"code_2\">data_nasterii.an=1990;</div>",
      "<div class=\"code_2\">st.an=1990;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details":
      "<p>R\u0103spuns corect: <strong>b) st.data_nasterii.an=1990</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>st</code> este de tip <code>Student</code>, trebuie s\u0103 acces\u0103m campul <code>an</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>st->data_nasterii->an=1990;</code> este incorect\u0103 deoarece <code>st</code> este o variabil\u0103 de tip <code>Student</code>, nu un pointer c\u0103tre <code>Student</code>. Accesarea cu <code>-&gt;</code> este incorect\u0103 \u00een acest context.</li>\n<li><strong>Op\u021biunea b)</strong> <code>st.data_nasterii.an=1990;</code> este corect\u0103 deoarece acceseaz\u0103 direct campul <code>an</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>data_nasterii.an=1990;</code> este incorect\u0103 deoarece <code>data_nasterii</code> nu este o variabil\u0103 accesibil\u0103 direct, ci un camp al variabilei <code>st</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>st.an=1990;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze un camp <code>an</code> care nu exist\u0103 direct \u00een structura <code>Student</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n\nint main() {\n    Student st;\n    st.data_nasterii.an = 1990;\n    printf(\"Anul nasterii: %d\\n\", st.data_nasterii.an);  // Afi\u0219eaz\u0103 anul na\u0219terii\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 25,
    "question": "ConsiderÄƒm urmÄƒtoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int x,y;<br>}Punct_2D;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct_2D p;<br><span class=\"tab\"></span>int z;<br>}Punct_3D;</div><br><br>È˜tiind cÄƒ variabila a este de tip Punct_3D, fiind folositÄƒ pentru a stoca coordonatele unui punct<br>Ã®n spaÈ›iu, indicaÈ›i instrucÅ£iunea de mai jos prin care toate cele 3 coordonate ale punctului a se iniÅ£ializeazÄƒ cu valoarea 0:<br>",
    "answers": [
      "<div class=\"code_2\">a.p.x = a.p.y = a.p.z = 0;</div>",
      "<div class=\"code_2\">a.p.x = a.p.y = a.z = 0;</div>",
      "<div class=\"code_2\">a.x = a.y = a.z = 0;</div>",
      "<div class=\"code_2\">a.p = a.z = 0;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>a) a.p.x = a.p.y = a.z = 0;</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int x, y;\n} Punct_2D;\n\ntypedef struct {\n    Punct_2D p;\n    int z;\n} Punct_3D;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>a</code> este de tip <code>Punct_3D</code>, trebuie s\u0103 acces\u0103m toate cele 3 coordonate ale punctului <code>a</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>a.p.x = a.p.y = a.z = 0;</code> este corect\u0103 deoarece acceseaz\u0103 direct coordonatele <code>x</code> \u0219i <code>y</code> ale punctului <code>a</code> \u0219i coordonata <code>z</code> a punctului <code>a</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>a.p.x = a.p.y = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze coordonata <code>z</code> a punctului <code>a</code> folosind <code>a.p</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>a.x = a.y = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze coordonatele <code>x</code>, <code>y</code> \u0219i <code>z</code> ale punctului <code>a</code> folosind <code>a</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>a.p = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 atribuie valoarea 0 variabilei <code>a.p</code>, care este de tip <code>Punct_2D</code>, nu unui intreg.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int x, y;\n} Punct_2D;\n\ntypedef struct {\n    Punct_2D p;\n    int z;\n} Punct_3D;\n\nint main() {\n    Punct_3D a;\n    a.p.x = a.p.y = a.z = 0;\n    printf(\"Coordonatele: (%d, %d, %d)\\n\", a.p.x, a.p.y, a.z);  // Afi\u0219eaz\u0103 coordonatele\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 26,
    "question": "ConsiderÄƒm tipul de date Punct, capabil sÄƒ memoreze abscisa ÅŸi ordonata unui punct din plan, ÅŸi tipul de date Segment, capabil sÄƒ memoreze douÄƒ puncte reprezentÃ¢nd extremitÄƒÅ£ile unui segment din plan, definite astfel:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>float x,y;<br>}Punct;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct A,B;<br>}Segment;</div><br><br>Care dintre urmÄƒtoarele expresii are o valoare nenulÄƒ dacÄƒ ÅŸi numai dacÄƒ variabila ğ‘  de tip Segment memoreazÄƒ informaÈ›ii despre un segment vertical (aflat pe axa Oy sau paralel cu axa Oy)?<br>",
    "answers": ["s.A == s.B", "s.x == s.y", "A.x == B.x", "s.A.x == s.B.x"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) s.A.x == s.B.x</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n</code></pre>\n<li>\u0218tim c\u0103 un segment vertical este definit de dou\u0103 puncte cu aceea\u0219i abscis\u0103, dar cu ordonate diferite.</li>\n<li>Prin urmare, pentru a verifica dac\u0103 un segment este vertical, putem compara abscisele celor dou\u0103 puncte ale segmentului.</li>\n<li><strong>Op\u021biunea a)</strong> <code>s.A == s.B</code> este incorect\u0103 deoarece compar\u0103 adresele celor dou\u0103 puncte ale segmentului, nu valorile acestora.</li>\n<li><strong>Op\u021biunea b)</strong> <code>s.x == s.y</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze c\u00e2mpurile <code>x</code> \u0219i <code>y</code> ale segmentului, care nu exist\u0103 direct.</li>\n<li><strong>Op\u021biunea c)</strong> <code>A.x == B.x</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze c\u00e2mpurile <code>x</code> ale punctelor <code>A</code> \u0219i <code>B</code> ale segmentului, care nu exist\u0103 direct.</li>\n<li><strong>Op\u021biunea d)</strong> <code>s.A.x == s.B.x</code> este corect\u0103 deoarece compar\u0103 abscisele celor dou\u0103 puncte ale segmentului, determin\u00e2nd dac\u0103 segmentul este vertical sau nu.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n\nint main() {\n    Segment s;\n    s.A.x = 1;\n    s.A.y = 2;\n    s.B.x = 1;\n    s.B.y = 3;\n    if(s.A.x == s.B.x) {\n        printf(\"Segmentul este vertical\");\n    } else {\n        printf(\"Segmentul nu este vertical\");\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 27,
    "question": "ConsiderÄƒm tipul de date Punct, capabil sÄƒ memoreze abscisa ÅŸi ordonata unui punct din plan, ÅŸi tipul de date Segment, capabil sÄƒ memoreze douÄƒ puncte reprezentÃ¢nd extremitÄƒÅ£ile unui segment din plan, definite astfel:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>float x,y;<br>}Punct;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct A,B;<br>}Segment;</div><br><br>Care dintre urmÄƒtoarele funcÈ›ii returneazÄƒ lungimea segmentului transmis prin intermediul parametrului s de tip Segment?<br>",
    "answers": [
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return pow(s.A.xâ€“s.B.x,2)+pow(s.A.yâ€“s.B.y,2);<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return sqrt((s.A.xâ€“s.B.x)+(s.A.yâ€“s.B.y));<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return s.B-s.A;<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return sqrt(pow(s.A.xâ€“s.B.x,2)+pow(s.A.yâ€“s.B.y,2));<br>}</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) double f(Segment s) { return sqrt(pow(s.A.xâ€“s.B.x,2)+pow(s.A.yâ€“s.B.y,2)); }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n</code></pre>\n<li>Func\u021bia <code>f</code> prime\u0219te un segment <code>s</code> ca parametru \u0219i returneaz\u0103 lungimea segmentului.</li>\n<li>Formula pentru calcularea lungimii unui segment \u00een plan este distan\u021ba euclidian\u0103 dintre cele dou\u0103 puncte care definesc segmentul.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 calculeze distan\u021ba euclidian\u0103 dintre punctele <code>A</code> \u0219i <code>B</code> ale segmentului <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>double f(Segment s) { return pow(s.A.xâ€“s.B.x,2)+pow(s.A.yâ€“s.B.y,2); }</code> este incorect\u0103 deoarece calculeaz\u0103 p\u0103tratul distan\u021bei euclidiene, nu distan\u021ba euclidian\u0103 \u00een sine.</li>\n<li><strong>Op\u021biunea b)</strong> <code>double f(Segment s) { return sqrt((s.A.xâ€“s.B.x)+(s.A.yâ€“s.B.y)); }</code> este incorect\u0103 deoarece calculeaz\u0103 suma diferen\u021belor dintre abscisele \u0219i ordonatele punctelor, nu distan\u021ba euclidian\u0103.</li>\n<li><strong>Op\u021biunea c)</strong> <code>double f(Segment s) { return s.B-s.A; }</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 scad\u0103 dou\u0103 structuri de tip <code>Punct</code>, care nu este permis.</li>\n<li><strong>Op\u021biunea d)</strong> <code>double f(Segment s) { return sqrt(pow(s.A.xâ€“s.B.x,2)+pow(s.A.yâ€“s.B.y,2)); }</code> este corect\u0103 deoarece calculeaz\u0103 distan\u021ba euclidian\u0103 dintre punctele <code>A</code> \u0219i <code>B</code> ale segmentului <code>s</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h>\n\ntypedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n\ndouble f(Segment s) {\n    return sqrt(pow(s.A.xâ€“s.B.x, 2) + pow(s.A.yâ€“s.B.y, 2));\n}\n\nint main() {\n    Segment s;\n    s.A.x = 1;\n    s.A.y = 2;\n    s.B.x = 4;\n    s.B.y = 6;\n    printf(\"Lungimea segmentului: %f\\n\", f(s));  // Afi\u0219eaz\u0103 lungimea segmentului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 28,
    "question": "ConsiderÄƒm funcÈ›ia <div class=\"code\">int suma(int x,int y)</div> care returneazÄƒ suma numerelor Ã®ntregi x È™i y, precum È™i funcÈ›ia <div class=\"code\">int prod(int x,int y)</div> care returneazÄƒ produsul numerelor Ã®ntregi x È™i y. È˜tiind cÄƒ a, b È™i c sunt 3 variabile de tip Ã®ntreg, care dintre expresiile de mai jos atribuie variabilei t de tip Ã®ntreg valoarea expresiei <div class=\"code\">(a+b)*(a+c)+b*c</div><br>",
    "answers": [
      "<div class=\"code_2\">t = prod(suma(a,b),suma(a,c),prod(b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(suma(a,b),suma(a,c)),suma(b,c));</div>",
      "<div class=\"code_2\">t = prod(suma(a,b),suma(a,c)+suma(b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(suma(a,b),suma(a,c)),prod(b,c));</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) t = suma(prod(suma(a,b),suma(a,c)),prod(b,c));</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 suma lor.</li>\n<li>Func\u021bia <code>prod</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 produsul lor.</li>\n<li>Expresia <code>(a+b)*(a+c)+b*c</code> reprezint\u0103 suma produsului dintre <code>a+b</code> \u0219i <code>a+c</code> \u0219i produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n<li>Prin urmare, pentru a atribui valoarea expresiei variabilei <code>t</code>, trebuie s\u0103 calcul\u0103m produsul dintre suma dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, apoi s\u0103 ad\u0103ug\u0103m produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>t = prod(suma(a,b), suma(a,c), prod(b,c));</code> este incorect\u0103 deoarece func\u021bia <code>prod</code> prime\u0219te doar dou\u0103 argumente, nu trei.</li>\n<li><strong>Op\u021biunea b)</strong> <code>t = suma(prod(suma(a,b), suma(a,c)), suma(b,c));</code> este incorect\u0103 deoarece adun\u0103 suma produsului dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, nu produsul acestora.</li>\n<li><strong>Op\u021biunea c)</strong> <code>t = prod(suma(a,b), suma(a,c) + suma(b,c));</code> este incorect\u0103 deoarece adun\u0103 suma dintre <code>a</code> \u0219i <code>c</code> \u0219i suma dintre <code>b</code> \u0219i <code>c</code>, nu produsul acestora.</li>\n<li><strong>Op\u021biunea d)</strong> <code>t = suma(prod(suma(a,b), suma(a,c)), prod(b,c));</code> este corect\u0103 deoarece calculeaz\u0103 suma produsului dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, apoi adaug\u0103 produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int x, int y) {\n    return x + y;\n}\n\nint prod(int x, int y) {\n    return x * y;\n}\n\nint main() {\n    int a = 1, b = 2, c = 3;\n    int t = suma(prod(suma(a, b), suma(a, c)), prod(b, c));\n    printf(\"Valoarea expresiei: %d\\n\", t);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 29,
    "question": "ConsiderÄƒm funcÈ›ia <div class=\"code\">int suma(int x,int y)</div> care returneazÄƒ suma numerelor Ã®ntregi x È™i y, precum È™i funcÈ›ia <div class=\"code\">int prod(int x,int y)</div> care returneazÄƒ produsul numerelor Ã®ntregi x È™i y. È˜tiind cÄƒ a, b È™i c sunt 3 variabile de tip Ã®ntreg, care dintre expresiile de mai jos atribuie variabilei t de tip Ã®ntreg valoarea expresiei <div class=\"code\">a*b+a*b*c</div><br>",
    "answers": [
      "<div class=\"code_2\">t = suma(prod(a,b),prod(a,b+c));</div>",
      "<div class=\"code_2\">t = suma(prod(a,b),prod(a,b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(a,b),prod(prod(a,b),c));</div>",
      "<div class=\"code_2\">t = prod(prod(a,b),suma(1,c));</div>"
    ],
    "correctAnswerIndexes": [2, 3],
    "details": "<p>R\u0103spuns corect: <strong>c) t = suma(prod(a,b), prod(prod(a,b), c));</strong> \u0219i <strong>d) t = prod(prod(a,b), suma(1, c));</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 suma lor.</li>\n<li>Func\u021bia <code>prod</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 produsul lor.</li>\n<li>Expresia <code>a*b+a*b*c</code> reprezint\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li>Prin urmare, pentru a atribui valoarea expresiei variabilei <code>t</code>, trebuie s\u0103 calcul\u0103m produsul dintre <code>a</code> \u0219i <code>b</code>, apoi s\u0103 ad\u0103ug\u0103m produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>t = suma(prod(a,b), prod(a,b+c));</code> este incorect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre <code>a</code> \u0219i <code>b+c</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>t = suma(prod(a,b), prod(a,b,c));</code> este incorect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre <code>a</code>, <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>t = suma(prod(a,b), prod(prod(a,b), c));</code> este corect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>t = prod(prod(a,b), suma(1, c));</code> este corect\u0103 deoarece calculeaz\u0103 produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre 1 \u0219i <code>c</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int x, int y) {\n    return x + y;\n}\n\nint prod(int x, int y) {\n    return x * y;\n}\n\nint main() {\n    int a = 1, b = 2, c = 3;\n    int t = suma(prod(a, b), prod(prod(a, b), c));\n    printf(\"Valoarea expresiei: %d\\n\", t);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 30,
    "question": "Care dintre urmÄƒtoarele funcÈ›ii returneazÄƒ suma cifrelor numÄƒrului natural n?",
    "answers": [
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n/10;<br><span class=\"tab_2\"></span>n=n%10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } return s; }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>f</code> prime\u0219te un num\u0103r natural <code>n</code> ca parametru \u0219i returneaz\u0103 suma cifrelor acestuia.</li>\n<li>Algoritmul pentru calcularea sumei cifrelor unui num\u0103r este de a parcurge cifrele num\u0103rului \u0219i de a le aduna \u00eentr-o variabil\u0103 auxiliar\u0103.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 parcurg\u0103 cifrele num\u0103rului \u0219i s\u0103 le adune \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } return s; }</code> este corect\u0103 deoarece parcurge cifrele num\u0103rului <code>n</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n/10; n=n%10; } return s; }</code> este incorect\u0103 deoarece adun\u0103 cifra unit\u0103\u021bilor la suma, nu cifra curent\u0103.</li>\n<li><strong>Op\u021biunea c)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } }</code> este incorect\u0103 deoarece nu returneaz\u0103 suma cifrelor num\u0103rului.</li>\n<li><strong>Op\u021biunea d)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=n%10; n=n/10; } return s; }</code> este incorect\u0103 deoarece atribuie cifra curent\u0103 variabilei <code>s</code>, nu o adun\u0103 la suma.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint f(int n) {\n    int s = 0;\n    while(n != 0) {\n        s = s + n % 10;\n        n = n / 10;\n    }\n    return s;\n}\n\nint main() {\n    int n = 12345;\n    printf(\"Suma cifrelor: %d\\n\", f(n));  // Afi\u0219eaz\u0103 suma cifrelor\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 31,
    "question": "Care dintre urmÄƒtoarele funcÈ›ii poate fi folositÄƒ Ã®ntr-un program pentru a citi de la tastaturÄƒ un<br>tablou unidimensional format din numere Ã®ntregi?",
    "answers": [
      "<div class=\"code_2\">void citire(int v[],int n) {<br><span class=\"tab\"></span>scanf(\"%d\",&n);<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int v[],int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",n);<br><span class=\"tab\"></span>for(int i=0;i&lt;*n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int *v[],int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",&n);<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int *v,int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",n);<br><span class=\"tab\"></span>for(int i=0;i&lt;*n;i++) scanf(\"%d\",v+i);<br>}</div>"
    ],
    "correctAnswerIndexes": [1, 3],
    "details": "<p>R\u0103spuns corect: <strong>b) void citire(int v[], int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", &v[i]); }</strong> \u0219i <strong>d) void citire(int *v, int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", v + i); }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>citire</code> prime\u0219te un tablou unidimensional <code>v</code> \u0219i un num\u0103r <code>n</code> de elemente \u0219i cite\u0219te valorile acestuia de la tastatur\u0103.</li>\n<li>Parametrul <code>n</code> este transmis prin referin\u021b\u0103 pentru a actualiza num\u0103rul de elemente citite.</li>\n<li>Algoritmul pentru citirea unui tablou unidimensional este de a citi num\u0103rul de elemente, apoi de a citi fiecare element \u00een parte.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 citeasc\u0103 num\u0103rul de elemente \u0219i apoi s\u0103 citeasc\u0103 fiecare element \u00een parte.</li>\n<li><strong>Op\u021biunea a)</strong> <code>void citire(int v[], int n) { scanf(\"%d\", &n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &v[i]); }</code> este incorect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u00eenainte de a citi elementele, ceea ce poate duce la erori.</li>\n<li><strong>Op\u021biunea b)</strong> <code>void citire(int v[], int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", &v[i]); }</code> este corect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u0219i apoi cite\u0219te fiecare element \u00een parte.</li>\n<li><strong>Op\u021biunea c)</strong> <code>void citire(int *v[], int *n) { scanf(\"%d\", &n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &v[i]); }</code> este incorect\u0103 deoarece transmite un pointer la un tablou de pointeri, nu un tablou unidimensional.</li>\n<li><strong>Op\u021biunea d)</strong> <code>void citire(int *v, int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", v + i); }</code> este corect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u0219i apoi cite\u0219te fiecare element \u00een parte folosind aritmetica pointerilor.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid citire(int v[], int *n) {\n    scanf(\"%d\", n);\n    for(int i = 0; i &lt; *n; i++)\n        scanf(\"%d\", &v[i]);\n}\n\nint main() {\n    int v[100], n;\n    citire(v, &n);  // Cite\u0219te un tablou unidimensional\n    for(int i = 0; i &lt; n; i++)\n        printf(\"%d \", v[i]);  // Afi\u0219eaz\u0103 elementele tabloului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 32,
    "question": "Care dintre urmÄƒtoarele funcÈ›ii returneazÄƒ suma elementelor tabloului unidimensional de<br>numere Ã®ntregi transmis ca parametru?",
    "answers": [
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0,k=0;<br><span class=\"tab\"></span>while(k&lt;n) s+=v[k++];<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0,k=0;<br><span class=\"tab\"></span>while(k++&lt;n) s+=v[k];<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s,k;<br><span class=\"tab\"></span>for(k=s=0;k&lt;n;s+=v[k++]);<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int k=n-1;k&gt;=0;k--) s+=v[n-k-1];<br><span class=\"tab\"></span>return s;<br>}</div>"
    ],
    "correctAnswerIndexes": [0, 2, 3],
    "details": "<p>R\u0103spuns corect: <strong>a) int suma(int v[], int n) { int s = 0, k = 0; while(k &lt; n) s += v[k++]; return s; }</strong>, <strong>c) int suma(int v[], int n) { int s, k; for(k = s = 0; k &lt; n; s += v[k++]); return s; </strong>\u0219i <strong>d) int suma(int v[], int n) { int s = 0; for(int k = n - 1; k &gt;= 0; k--) s += v[n - k - 1]; return s; }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te un tablou unidimensional <code>v</code> \u0219i un num\u0103r <code>n</code> de elemente \u0219i returneaz\u0103 suma elementelor acestuia.</li>\n<li>Algoritmul pentru calcularea sumei elementelor unui tablou unidimensional este de a parcurge elementele \u0219i de a le aduna \u00eentr-o variabil\u0103 auxiliar\u0103.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 parcurg\u0103 elementele tabloului \u0219i s\u0103 le adune \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>int suma(int v[], int n) { int s = 0, k = 0; while(k &lt; n) s += v[k++]; return s; }</code> este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>int suma(int v[], int n) { int s = 0, k = 0; while(k++ &lt; n) s += v[k]; return s; }</code> este incorect\u0103 deoarece incrementeaz\u0103 <code>k</code> \u00eenainte de a aduna elementul la sum\u0103, ceea ce poate duce la erori.</li>\n<li><strong>Op\u021biunea c)</strong> <code>int suma(int v[], int n) { int s, k; for(k = s = 0; k &lt; n; s += v[k++]); return s; </code>este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>int suma(int v[], int n) { int s = 0; for(int k = n - 1; k &gt;= 0; k--) s += v[n - k - 1]; return s; }</code> este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code> \u00een ordine invers\u0103.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int v[], int n) {\n    int s = 0, k = 0;\n    while(k &lt; n)\n        s += v[k++];\n    return s;\n}\n\nint main() {\n    int v[] = {1, 2, 3, 4, 5};\n    int n = 5;\n    printf(\"Suma elementelor: %d\\n\", suma(v, n));  // Afi\u0219eaz\u0103 suma elementelor\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 33,
    "question": "FuncÈ›ia minmax primeÈ™te prin parametrul de intrare v un tablou unidimensional format din numere Ã®ntregi, iar prin parametrul de intrare n primeÈ™te numÄƒrul de elemente ale tabloului v. FuncÈ›ia trebuie sÄƒ Ã®ntoarcÄƒ prin doi parametri de ieÈ™ire, min È™i max, valoarea minimÄƒ È™i, respectiv, valoarea maximÄƒ din tabloul v. Care dintre urmÄƒtoarele variante reprezintÄƒ un antet corect al funcÈ›iei minmax?",
    "answers": [
      "<div class=\"code_2\">void minmax(int v[],int n,int min,int max)</div>",
      "<div class=\"code_2\">int minmax(int v[],int n,int min,int max)</div>",
      "<div class=\"code_2\">void minmax(int v[],int n,int *min,int *max)</div>",
      "<div class=\"code_2\">void minmax(int *v[],int *n,int *min,int *max)</div>"
    ],
    "correctAnswerIndexes": [2]
  },
  {
    "id": 34,
    "question": "Fie v un tablou unidimensional format din 100 de numere reale de tip double È™i numÄƒrul natural k cuprins Ã®ntre 0 È™i 99. Care dintre urmÄƒtoarele expresii afiÈ™eazÄƒ adresa elementului v[k]?",
    "answers": [
      "<div class=\"code_2\">printf(\"%p\",v+k);</div>",
      "<div class=\"code_2\">printf(\"%p\",*(v+k));</div>",
      "<div class=\"code_2\">printf(\"%p\",v+k*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%p\",&v[k]);</div>"
    ],
    "correctAnswerIndexes": [0, 3]
  },
  {
    "id": 35,
    "question": "Fie ğ‘£ un tablou unidimensional format din 100 de numere reale de tip double È™i ğ‘ o variabilÄƒ de tip pointer cÄƒtre double Ã®n care este memoratÄƒ adresa ultimului element al tabloului ğ‘£ (double *p=&v[99];). Care dintre urmÄƒtoarele expresii afiÈ™eazÄƒ numÄƒrul de octeÈ›i pe care<br>Ã®i ocupÄƒ tabloul ğ‘£ Ã®n memorie?",
    "answers": [
      "<div class=\"code_2\">printf(\"%d\",(p-v)*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%d\",100*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%d\",p-v);</div>",
      "<div class=\"code_2\">printf(\"%d\",sizeof(v));</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 36,
    "question": "Care dintre urmÄƒtoarele secvenÈ›e de cod poate fi utilizatÄƒ pentru a aloca dinamic un tablou unidimensional ğ‘ format din 100 de numere Ã®ntregi?",
    "answers": [
      "<div class=\"code_2\">int *a = (int *)malloc(100*sizeof(int *));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(100*sizeof(int));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(100);</div>",
      "<div class=\"code_2\">int *a = (int *)calloc(100,sizeof(int));</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 37,
    "question": "Care dintre urmÄƒtoarele secvenÈ›e de cod poate fi utilizatÄƒ pentru a aloca dinamic un tablou bidimensional ğ‘ format din 10 de linii È™i 20 de coloane de numere Ã®ntregi?",
    "answers": [
      "<div class=\"code_2\">int **a = (int **)malloc(10*sizeof(int *));<br>for(int i=0;i&lt;10;i++)<br><span class=\"tab\"></span>a[i]=(int *)malloc(20*sizeof(int));</div>",
      "<div class=\"code_2\">int **a = (int **)calloc(10*sizeof(int *),20*sizeof(int));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(20*sizeof(int *));<br>for(int i=0;i&lt;20;i++)<br><span class=\"tab\"></span>a[i]=(int *)malloc(10*sizeof(int));</div>",
      "<div class=\"code_2\">int **a = (int **)calloc(10,sizeof(int*));<br>for(int i=0;i&lt;10;i++)<br><span class=\"tab\"></span>a[i]=(int *)calloc(20,sizeof(int));</div>"
    ],
    "correctAnswerIndexes": [0, 3]
  },
  {
    "id": 38,
    "question": "Fie ğ‘ un tabloul bidimensional pÄƒtratic de dimensiune ğ‘›. Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ elementele aflate pe diagonala principalÄƒ a matricei ğ‘?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i==j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][i]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i+j==n-1) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][n-i-1]);</div>"
    ],
    "correctAnswerIndexes": [0, 1]
  },
  {
    "id": 39,
    "question": "Fie ğ‘ un tabloul bidimensional pÄƒtratic de dimensiune ğ‘›. Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ elementele aflate pe diagonala secundarÄƒ a matricei ğ‘?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i==j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][i]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i+j==n-1) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][n-i-1]);</div>"
    ],
    "correctAnswerIndexes": [2, 3]
  },
  {
    "id": 40,
    "question": "Fie ğ‘ un tabloul bidimensional pÄƒtratic de dimensiune ğ‘›. Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ elementele triunghiului delimitat de prima coloanÄƒ, diagonala principalÄƒ È™i ultima linie din matricea ğ‘?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&gt;=j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&lt;=j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;=i;j++) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=i;j&lt;n;j++) printf(\"%d \",a[i][j]);</div>"
    ],
    "correctAnswerIndexes": [0, 2]
  },
  {
    "id": 41,
    "question": "Fie ğ‘ un tabloul bidimensional pÄƒtratic de dimensiune ğ‘›. Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ elementele triunghiului delimitat de diagonala principalÄƒ, ultima coloanÄƒ È™i ultima linie din matricea ğ‘?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&gt;=j) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&lt;=j) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;=i;j++) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=i;j&lt;n;j++) printf(\"%d \",a[i][j]);"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 42,
    "question": "Fie ğ‘ un tabloul bidimensional pÄƒtratic de dimensiune ğ‘›. Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ suma elementelor de pe fiecare linie a matricei ğ‘?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) {<br><span class=\"tab_2\"></span>s=s+a[i][j];<br><span class=\"tab_2\"></span>printf(\"%d \",s);<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int s=0;<br>for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) {<br><span class=\"tab_2\"></span>s=s+a[i][j];<br><span class=\"tab_2\"></span>printf(\"%d \",s);<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int s=0;<br>for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) s=s+a[i][j];<br><span class=\"tab\"></span>printf(\"%d \",s);<br>}<br></div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) s=s+a[i][j];<br><span class=\"tab\"></span>printf(\"%d \",s);<br>}</div>"
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 43,
    "question": "Care dintre urmÄƒtoarele funcÈ›ii returneazÄƒ dimensiunea Ã®n octeÈ›i a unui fiÈ™ier text a cÄƒrui cale<br>este transmisÄƒ prin parametrul de intrare ğ‘›ğ‘“?",
    "answers": [
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>fseek(f,0,SEEK_END);<br><span class=\"tab\"></span>int n=ftell(f);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char c;<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(!feof(f)) {<br><span class=\"tab_2\"></span>fscanf(f,\"%c\",&c);<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n+1;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=sizeof(f);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fgets(s,1000,f))<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>"
    ],
    "correctAnswerIndexes": [0, 1]
  },
  {
    "id": 44,
    "question": "Care dintre urmÄƒtoarele funcÈ›ii returneazÄƒ numÄƒrul de linii dintr-un fiÈ™ier text a cÄƒrui cale este transmisÄƒ prin parametrul de intrare ğ‘›ğ‘“ (se presupune cÄƒ fiÈ™ierul nu conÈ›ine linii vide)?",
    "answers": [
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fscanf(f,\"%s\",s)==1)<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char c;<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fscanf(f,\"%c\",&c)==1)<br><span class=\"tab_2\"></span>if(c=='\\n') n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=sizeof(f);<br><span class=\"tab\"></span>fclose (f);<br><span class=\"tab\"></span>return n/sizeof(char *);<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fgets(s,1000,f))<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose (f);<br><span class=\"tab\"></span>return n;<br>}</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 45,
    "question": "ConsiderÄƒm urmÄƒtorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>#include&lt;stdio.h&gt;<br>int main() {<br><span class=\"tab\"></span>FILE *f=fopen(\"test.txt\",\"r\");<br><span class=\"tab\"></span>char s[101],t[101];<br><span class=\"tab\"></span>while(fgets(s,100,f))<br><span class=\"tab_2\"></span>strcpy(t,s);<br><span class=\"tab\"></span>printf(\"%s\",t);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>È˜tiind ca lungimea maximÄƒ a unei linii din fiÈ™ierul text test.txt este de 100 de caractere, ce se va afiÈ™a dupÄƒ executarea programului de mai sus?",
    "answers": [
      "fiecare linie din fiÈ™ier;",
      "penultima linie din fiÈ™ier;",
      "ultimul caracter din fiÈ™ier;",
      "ultima linie din fiÈ™ier."
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 46,
    "question": "ConsiderÄƒm urmÄƒtorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>#include&lt;stdio.h&gt;<br>int main() {<br><span class=\"tab\"></span>char s[21],aux[11];<br><span class=\"tab\"></span>strcpy(s,\"\");<br><span class=\"tab\"></span>for(int i=1;i&lt;=5;i++) {<br><span class=\"tab_2\"></span>printf(\"Sirul %d: \",i);<br><span class=\"tab_2\"></span>gets(aux);<br><span class=\"tab_2\"></span>â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>printf(\"%s\",s);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>PresupunÃ¢nd cÄƒ fiecare dintre cele 5 È™iruri care vor fi citite de la tastaturÄƒ vor fi formate din minim douÄƒ caractere È™i maxim 10, stabiliÈ›i cu care dintre instrucÈ›iunile de mai jos trebuie Ã®nlocuite spaÈ›iile punctate din program astfel Ã®ncÃ¢t acesta sÄƒ afiÈ™eze È™irul format din ultimele douÄƒ caractere din fiecare dintre cele 5 È™iruri citite:",
    "answers": [
      "<div class=\"code_2\">strcat(s,aux+9);</div>",
      "<div class=\"code_2\">strcat(s,aux[strlen(aux)-1]);</div>",
      "<div class=\"code_2\">strncat(s,aux,strlen(aux)-1);</div>",
      "<div class=\"code_2\">strcat(s,aux+strlen(aux)-2);</div>"
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 47,
    "question": "Care dintre urmÄƒtoarele secvenÈ›e de cod afiÈ™eazÄƒ pe ecran È™irul de numere 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5?",
    "answers": [
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=5;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);",
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=i;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);",
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=i;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",j);",
      "<div class=\"code_2\">for(int i=1;i&lt;=4;i++)<br><span class=\"tab\"></span>for(int j=i+1;j&lt;=5;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);"
    ],
    "correctAnswerIndexes": [1]
  },
  {
    "id": 48,
    "question": "StabiliÈ›i care dintre urmÄƒtoarele funcÈ›ii Ã®ntorc poziÈ›ia primei valori strict pozitive din tabloul ğ‘£ format din ğ‘› numere Ã®ntregi sau -1 dacÄƒ tabloul nu conÈ›ine nici un numÄƒr pozitiv:",
    "answers": [
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i,x=-1;<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if(v[i]&gt;0) x=i;<br><span class=\"tab\"></span>return x;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int x=0;<br><span class=\"tab\"></span>while(v[x]&lt;=0) x++;<br><span class=\"tab\"></span>return x-1;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i,x=-1;<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if((v[i]&gt;0)&&(x<0)) x=i;<br><span class=\"tab\"></span>return x;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i;<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if (v[i]&gt;0) return i;<br><span class=\"tab\"></span>return -1;<br>}</div>"
    ],
    "correctAnswerIndexes": [2, 3]
  },
  {
    "id": 49,
    "question": "ConsiderÄƒm urmÄƒtoarea secvenÈ›Äƒ de cod:<br><br><div class=\"code\">int a, b, p=1;<br>scanf(\"%d %d\", &a, &b);<br>while(p &lt; a)<br><span class=\"tab\"></span>p = p*2;<br>while(p &lt;= b) {<br><span class=\"tab\"></span>printf(\"%d\", p);<br><span class=\"tab\"></span>p = p*2;<br>}</div><br><br>DacÄƒ valorile introduse pentru variabilele a È™i b vor fi douÄƒ numere naturale nenule cu proprietatea cÄƒ a &lt; b, atunci pe ecran se vor afiÈ™a:",
    "answers": [
      "toate puterile lui 2 din intervalul [a,b];",
      "toate puterile lui 2 din intervalul (a,b];",
      "toate numerele pare din intervalul [a,b];",
      "toate numerele pare din intervalul (a,b];"
    ],
    "correctAnswerIndexes": [0]
  },
  {
    "id": 50,
    "question": "ConsiderÄƒm urmÄƒtorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>void p(int v[],int *n) {<br><span class=\"tab\"></span>int i,j,g;<br><span class=\"tab\"></span>do {<br><span class=\"tab_2\"></span>g=0;<br><span class=\"tab_2\"></span>for(i=0;i&lt;*n;i++)<br><span class=\"tab_3\"></span>if(v[i]&lt;0) {<br><span class=\"tab_4\"></span>for(j=i;j&lt;*n-1;j++) v[j]=v[j+1];<br><span class=\"tab_4\"></span>(*n)--;<br><span class=\"tab_4\"></span>g=1;<br><span class=\"tab_3\"></span>}<br><span class=\"tab_2\"></span>}<br><span class=\"tab\"></span>while(g);<br>}<br><br>int main() {<br><span class=\"tab\"></span>int i,v[]={-1,2,-3,-4,5},n=5;<br><span class=\"tab\"></span>p(v,&n);<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>printf(\"%d \",v[i]);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori vor fi afiÈ™ate pe ecran dupÄƒ executarea programului de mai sus?",
    "answers": ["â€“1 -3 -4", "2 5", "â€“1 2 -3 -4", "2 -3 -4 5"],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) 2 5</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Programul de mai sus elimin\u0103 toate valorile negative din tabloul <code>v</code>. Func\u021bia <code>p</code> prime\u0219te un tablou de numere \u00eentregi <code>v</code> \u0219i un pointer <code>n</code> care reprezint\u0103 num\u0103rul de elemente din tablou.</li>\n<li><strong>Ini\u021bializarea \u0219i bucla <code>do-while</code></strong>: <code>do { g = 0; for (i = 0; i < *n; i++) { if (v[i] < 0) { for (j = i; j < *n - 1; j++) { v[j] = v[j + 1]; } (*n)--; g = 1; break; } } } while (g);</code> - <code>g</code> este un flag care indic\u0103 dac\u0103 a fost eliminat un element negativ. - Bucla <code>for</code> itereaz\u0103 prin toate elementele tabloului <code>v</code>. - Dac\u0103 un element <code>v[i]</code> este negativ, acesta este eliminat prin mutarea tuturor elementelor urm\u0103toare cu o pozi\u021bie spre st\u00e2nga. - Dimensiunea tabloului <code>n</code> este decrementat\u0103. - <code>g</code> este setat la 1 pentru a continua bucla <code>do-while</code>.</li>\n<li><strong>Apelarea func\u021biei <code>p</code> \u0219i afi\u0219area rezultatului</strong>: <code>p(v, &n); for (i = 0; i < n; i++) printf(\"%d \", v[i]);</code> - Func\u021bia <code>p</code> este apelat\u0103 pentru a elimina valorile negative din <code>v</code>. - Valorile r\u0103mase \u00een <code>v</code> sunt afi\u0219ate pe ecran.</li>\n<li>Programul va elimina toate valorile negative din tabloul <code>v</code>, l\u0103s\u00e2nd doar valorile <code>2</code> \u0219i <code>5</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid p(int v[], int *n) {\n    int i, j, g;\n    do {\n        g = 0;\n        for (i = 0; i < *n; i++) {\n            if (v[i] < 0) {\n                for (j = i; j < *n - 1; j++) {\n                    v[j] = v[j + 1];\n                }\n                (*n)--;\n                g = 1;\n                break;\n            }\n        }\n    } while (g);\n}\n\nint main() {\n    int i, v[] = { -1, 2, -3, -4, 5 }, n = 5;\n    p(v, &n);\n    for (i = 0; i < n; i++)\n        printf(\"%d \", v[i]);\n    return 0;\n}\n</code></pre>"
  }
]
