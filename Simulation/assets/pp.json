[
  {
    "id": 1,
    "question": "În care dintre variantele de mai jos se declară un tablou unidimensional (vector) 𝑥 în care se pot memora cel mult 100 de numere reale?",
    "answers": [
      "<div class=\"code_2\">x=float[100];</div>",
      "<div class=\"code_2\">double x[100];</div>",
      "<div class=\"code_2\">float x[100];</div>",
      "<div class=\"code_2\">real x(100);</div>"
    ],
    "correctAnswerIndexes": [1, 2],
    "details": "<p>\u00cen limbajul de programare C, un tablou unidimensional (vector) \u00een care se pot memora cel mult 100 de numere reale se declar\u0103 corect folosind urm\u0103toarele variante:</p>\n<ul>\n<li>b) <code>double x[100];</code></li>\n<li>c) <code>float x[100];</code></li>\n</ul>\n<p><strong>Explica\u021bie:</strong></p>\n<ul>\n<li><code>double x[100];</code> declar\u0103 un vector de 100 de elemente de tip <code>double</code>, care reprezint\u0103 numere reale pe 64 de bi\u021bi.</li>\n<li><code>float x[100];</code> declar\u0103 un vector de 100 de elemente de tip <code>float</code>, care reprezint\u0103 numere reale pe 32 de bi\u021bi.</li>\n</ul>\n<p>Celelalte op\u021biuni nu sunt corecte \u00een limbajul C:</p>\n<ul>\n<li>a) <code>x=float[100];</code> nu este o sintax\u0103 corect\u0103 \u00een C.</li>\n<li>d) <code>real x(100);</code> nu este o sintax\u0103 corect\u0103 \u00een C.</li>\n</ul>"
  },
  {
    "id": 2,
    "question": "Care dintre următoarele expresii logice este adevărată (are o valoare nenulă) dacă şi numai dacă numărul real memorat în variabila 𝑥 nu aparţine intervalului (0,5]?",
    "answers": [
      "<div class=\"code_2\">(x&lt;=0)||(x&gt;5)</div>",
      "<div class=\"code_2\">(x&lt;=0)&&(x&gt;5)</div>",
      "<div class=\"code_2\">(x&lt;0)||(x&gt;=5)</div>",
      "<div class=\"code_2\">(x&lt;=0)&&(x&gt;5)</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) (x<=0)||(x>5)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Intervalul (0,5] \u00eenseamn\u0103 c\u0103 \ud835\udc65 trebuie s\u0103 fie mai mare dec\u00e2t 0 \u0219i mai mic sau egal cu 5.</li>\n<li>Pentru ca \ud835\udc65 s\u0103 nu apar\u021bin\u0103 acestui interval, \ud835\udc65 trebuie s\u0103 fie fie mai mic sau egal cu 0 (<code>x<=0</code>), fie mai mare dec\u00e2t 5 (<code>x>5</code>).</li>\n<li>Combina\u021bia logic\u0103 <code>(x<=0)||(x>5)</code> este adev\u0103rat\u0103 doar atunci c\u00e2nd \ud835\udc65 nu apar\u021bine intervalului (0,5].</li>\n</ul>"
  },
  {
    "id": 3,
    "question": "Care dintre următoarele expresii este adevărată (are o valoare nenulă) dacă şi numai dacă numărul întreg memorat în variabila 𝑥 aparţine intervalului (1,6]?",
    "answers": [
      "<div class=\"code_2\">(x&gt;=1)||(x&lt;6)</div>",
      "<div class=\"code_2\">(x&gt;1)||(x&lt;=6)</div>",
      "<div class=\"code_2\">(x&gt;1)&&(x&lt;6)</div>",
      "<div class=\"code_2\">(x&gt;1)&&(x&lt;=6)</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) (x>1)&&(x<=6)</strong></p>\n<p>Expresia corect\u0103 este <code>(x>1)&&(x<=6)</code> deoarece:</p>\n<ul>\n<li>Intervalul (1,6] \u00eenseamn\u0103 c\u0103 \ud835\udc65 trebuie s\u0103 fie mai mare dec\u00e2t 1 \u0219i mai mic sau egal cu 6.</li>\n<li>Expresia <code>(x>1)</code> verific\u0103 dac\u0103 \ud835\udc65 este mai mare dec\u00e2t 1.</li>\n<li>Expresia <code>(x<=6)</code> verific\u0103 dac\u0103 \ud835\udc65 este mai mic sau egal cu 6.</li>\n<li>Astfel, expresia <code>(x>1)&&(x<=6)</code> este adev\u0103rat\u0103 doar atunci c\u00e2nd \ud835\udc65 apar\u021bine intervalului (1,6].</li>\n</ul>"
  },
  {
    "id": 4,
    "question": "După executarea instrucțiunii float x = 27/5*2/3*7; ce valoare va fi memorată în variabila 𝑥?",
    "answers": ["25.2", "21", "6.3", "7"],
    "correctAnswerIndexes": [1],
    "details": "<p>Dup\u0103 executarea instruc\u021biunii <code>float x = 27/5*2/3*7;</code> valoarea memorat\u0103 \u00een variabila \ud835\udc65 va fi 21 deoarece:</p>\n<ul>\n<li>Opera\u021biile se efectueaz\u0103 conform ordinii de preceden\u021b\u0103 \u0219i cu tipuri de date implicite (\u00een acest caz, \u00eentregi).</li>\n<li><code>27 / 5</code> se evalueaz\u0103 ca 5 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>5 * 2</code> se evalueaz\u0103 ca 10.</li>\n<li><code>10 / 3</code> se evalueaz\u0103 ca 3 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>3 * 7</code> se evalueaz\u0103 ca 21.</li>\n<li>Rezultatul final este 21, care este apoi convertit la <code>float</code> \u0219i stocat \u00een variabila <code>x</code>.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>b) 21</strong></p>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float x = 27 / 5 * 2 / 3 * 7;  // Instruc\u021biunea dat\u0103\n    printf(\"x = %f\\n\", x);         // Afi\u0219eaz\u0103 valoarea lui x\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 5,
    "question": "După executarea instrucțiunii float x = 55/17*5/8+48/5/8*15; ce valoare va fi memorată în variabila 𝑥?",
    "answers": ["17.022058", "17", "16", "21.219914"],
    "correctAnswerIndexes": [2],
    "details": "<p>Dup\u0103 executarea instruc\u021biunii <code>float x = 55/17*5/8+48/5/8*15;</code> valoarea memorat\u0103 \u00een variabila \ud835\udc65 va fi **16.0** deoarece:</p>\n<ul>\n<li>Opera\u021biile se efectueaz\u0103 conform ordinii de preceden\u021b\u0103 \u0219i cu tipuri de date implicite (\u00een acest caz, \u00eentregi).</li>\n<li><code>55 / 17</code> se evalueaz\u0103 ca 3 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>3 * 5</code> se evalueaz\u0103 ca 15.</li>\n<li><code>15 / 8</code> se evalueaz\u0103 ca 1 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>48 / 5</code> se evalueaz\u0103 ca 9 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>9 / 8</code> se evalueaz\u0103 ca 1 (\u00eemp\u0103r\u021bire \u00eentre \u00eentregi).</li>\n<li><code>1 * 15</code> se evalueaz\u0103 ca 15.</li>\n<li><code>1 + 15</code> se evalueaz\u0103 ca 16.</li>\n<li>Deoarece variabila \ud835\udc65 este de tip float, rezultatul 16 este convertit implicit la 16.0 \u0219i stocat \u00een variabila <code>x</code>.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>c) 16</strong></p>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float x = 55 / 17 * 5 / 8 + 48 / 5 / 8 * 15;  // Instruc\u021biunea dat\u0103\n    printf(\"x = %f\\n\", x);         // Afi\u0219eaz\u0103 valoarea lui x\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 6,
    "question": "Se consideră următoarea secvenţă de instrucțiuni:<br><br><div class=\"code\">int t=0,a=1234,b=10;<br>while(a&gt;=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div><br><br>Ce valori vor fi afișate pe ecran după executarea secvenței de mai sus?",
    "answers": ["124 4", "123 4", "123 5", "124 3"],
    "correctAnswerIndexes": [1],
    "details": "<p>Valorile afi\u0219ate pe ecran vor fi <b>123 4</b>.</p>\n<p>Explica\u021bie:</p>\n<ul>\n<li>Ini\u021bial, <code>t = 0</code>, <code>a = 1234</code> \u0219i <code>b = 10</code>.</li>\n<li>Ciclul <code>while</code> se execut\u0103 c\u00e2t timp <code>a</code> este mai mare sau egal cu <code>b</code>.</li>\n<li>La fiecare itera\u021bie:\n<ul>\n<li><code>a</code> este decrementat cu valoarea lui <code>b</code> (<code>a = a - b</code>).</li>\n<li><code>t</code> este incrementat cu 1 (<code>t++</code>).</li>\n</ul>\n</li>\n<li>Ciclul se opre\u0219te c\u00e2nd <code>a</code> devine mai mic dec\u00e2t <code>b</code>.</li>\n<li>Dup\u0103 executarea ciclului, valorile finale sunt <code>t = 123</code> \u0219i <code>a = 4</code>.</li>\n<li>Instruc\u021biunea <code>printf</code> afi\u0219eaz\u0103 aceste valori separate prin spa\u021biu.</li>\n</ul>\n<p>R\u0103spuns corect: <strong>b) 123 4</strong></p>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int t = 0, a = 1234, b = 10;\n    while (a >= b) {\n        a = a - b;\n        t++;\n    }\n    printf(\"%d %d\\n\", t, a);\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 7,
    "question": "Care dintre următoarele secvenţe de instrucţiuni afişează valoarea 654, ştiind că 𝑠 şi 𝑖 sunt două variabile de tip întreg?",
    "answers": [
      "<div class=\"code_2\">s=0;<br>for(i=0;i&lt;=654;i++) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">s=651;<br>while(s&lt;=654) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">for(i=1;i&lt;=3;i++) printf(\"%d\",7-i);</div>",
      "<div class=\"code_2\">s=7;<br>while(s&gt;=1) printf(\"%d\",s-1);</div>"
    ],
    "correctAnswerIndexes": [2],
    "details": "<p>R\u0103spuns corect: <strong>c) for(i=1;i<=3;i++) printf(\"%d\",7-i);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Secven\u021ba <code>for(i=1;i<=3;i++) printf(\"%d\",7-i);</code> afi\u0219eaz\u0103 valorile 6, 5 \u0219i 4, concaten\u00e2ndu-le \u00een 654.</li>\n<li>Variabila <code>i</code> ia valorile de la 1 la 3.</li>\n<li>La fiecare itera\u021bie, se afi\u0219eaz\u0103 <code>7-i</code>, astfel rezult\u00e2nd 6, 5 \u0219i 4.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i;\n    for(i = 1; i <= 3; i++) {\n        printf(\"%d\", 7 - i);\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 8,
    "question": "Care dintre următoarele secvenţe de instrucţiuni afişează valoarea 5432, ştiind că 𝑠 şi 𝑖 sunt două variabile de tip întreg?",
    "answers": [
      "<div class=\"code_2\">s=0;<br>for(i=0;i&lt;=5432;i++) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">s=5421;<br>while(s&lt;=5432) s++;<br>printf(\"%d\",s);</div>",
      "<div class=\"code_2\">for(i=1;i&lt;4;i++) printf(\"%d\",6-i);</div>",
      "<div class=\"code_2\">s=6;<br>while(s&gt;=3) printf(\"%d\",--s);</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) s=6;<br>while(s>=3) printf(\"%d\",--s);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, <code>s</code> este setat\u0103 la 6.</li>\n<li>\u00cen fiecare itera\u021bie a buclei <code>while</code>, valoarea lui <code>s</code> este decrementat\u0103 cu 1 \u00eenainte de a fi afi\u0219at\u0103.</li>\n<li>Buclele \u0219i afi\u0219\u0103rile sunt: 5, 4, 3 \u0219i astfel rezult\u0103 afi\u0219area valorii concatenat\u0103 5432.</li>\n<li>Decrementarea cu operatorul prefix <code>--s</code> asigur\u0103 c\u0103 valoarea lui <code>s</code> este redus\u0103 \u00eenainte de a fi folosit\u0103 \u00een <code>printf</code>.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int s = 6;\n    while(s >= 3) {\n        printf(\"%d\", --s);\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 9,
    "question": "Considerăm următoarea secvenţă de instrucțiuni:<br><br><div class=\"code\">s = 1;<br>while(n>0) {<br><span class=\"tab\"></span>if(n%10>s) s=n%10;<br><span class=\"tab\"></span>else s=10;<br><span class=\"tab\"></span>n=n/10;<br>}<br>printf(\"%d\",s);</div><br><br>Ştiind că variabilele 𝑠 şi 𝑛 sunt de tip întreg, ce valoare se va afişa după executarea secvenţei de mai sus pentru 𝑛 = 9321?",
    "answers": ["9", "10", "15", "1"],
    "correctAnswerIndexes": [1],
    "details":"Observatii_Prof:Greseala principala consta in faptul ca variabila s nu este initializata. Daca s = 0 atunci secventa va afisa valoarea 9 (cifra maxima), altfel va afisa valoarea 10. In concluzie, va rog sa adaugati <b>initializarea s = 1</b> si raspunsul corect va ramane cel marcat acum (10)<span style='color: red;'>Atentie!!! In grile pdf raspunsul corect este b) 10</span><br>Pas cu pas pentru <i>n = 9321</i>:<br><br><b>Prima iterare:</b><ul><li><i>n = 9321</i></li><li><i>n % 10 = 1</i></li><li><i>s = 1</i></li><li><i>1 <= 1</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 932</i></li></ul><b>A doua iterare:</b><ul><li><i>n = 932</i></li><li><i>n % 10 = 2</i></li><li><i>s = 10</i></li><li><i>2 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 93</i></li></ul><b>A treia iterare:</b><ul><li><i>n = 93</i></li><li><i>n % 10 = 3</i></li><li><i>s = 10</i></li><li><i>3 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 9</i></li></ul><b>A patra iterare:</b><ul><li><i>n = 9</i></li><li><i>n % 10 = 9</i></li><li><i>s = 10</i></li><li><i>9 <= 10</i>, deci <i>s = 10</i></li><li><i>n = n / 10 = 0</i></li></ul><br>La final, <i>n = 0</i> \u0219i ie\u0219im din bucl\u0103. Variabila <i>s</i> are valoarea 10.<br><br>Deci valoarea afi\u0219at\u0103 va fi:<br><br>b) 10\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int s = 1; // Ini\u021bializare conform observa\u021biilor profesorului\n    int n = 9321;\n\n    while(n > 0) {\n        if(n % 10 > s) s = n % 10;\n        else s = 10;\n        n = n / 10;\n    }\n\n    printf(\"%d\", s);\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 10,
    "question": "Care dintre următoarele secvenţe de instrucțiuni afişează câtul şi restul împărţirii numărului natural 𝑎 la numărul natural nenul 𝑏?",
    "answers": [
      "<div class=\"code_2\">int t=0;<br>while(a&gt;=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div>",
      "<div class=\"code_2\">int t=0;<br>do {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>} while(a&gt;=b);<br>printf(\"%d %d\",t,a);</div>",
      "<div class=\"code_2\">int t=0;<br>while(a!=b) {<br><span class=\"tab\"></span>a=a-b;<br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,b);</div>",
      "<div class=\"code_2\">int t=0;<br>while(a%b==0) {<br><span class=\"tab\"></span>a=a-b;<span class=\"tab\"></span><br><span class=\"tab\"></span>t++;<br>}<br>printf(\"%d %d\",t,a);</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "Observatie_Nelu: se pare ca a) si b) au acelasi rezultat.<p>R\u0103spuns corect: <strong>a) int t=0;<br>while(a>=b)<br>{<br>a=a-b;<br>t++;<br>}<br>printf(\"%d %d\",t,a);</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Secven\u021ba de instruc\u021biuni \u00een varianta a) realizeaz\u0103 \u00eemp\u0103r\u021birea repetat\u0103 a lui <code>a</code> la <code>b</code> prin sc\u0103deri succesive.</li>\n<li>Variabila <code>t</code> num\u0103r\u0103 de c\u00e2te ori <code>b</code> a fost sc\u0103zut din <code>a</code>, reprezent\u00e2nd astfel c\u00e2tul \u00eemp\u0103r\u021birii.</li>\n<li>La finalul buclei, <code>a</code> con\u021bine restul \u00eemp\u0103r\u021birii.</li>\n<li>Instruc\u021biunea <code>printf(\"%d %d\",t,a);</code> afi\u0219eaz\u0103 c\u00e2tul \u0219i restul \u00eemp\u0103r\u021birii.</li>\n</ul>\n<p>Cod C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 1234; // Exemplu valoare pentru a\n    int b = 10;   // Exemplu valoare pentru b\n    int t = 0;\n    while(a >= b) {\n        a = a - b;\n        t++;\n    }\n    printf(\"%d %d\", t, a);\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 11,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(int a, int *b) {<br><span class=\"tab\"></span>int aux;<br><span class=\"tab\"></span>aux = a;<br><span class=\"tab\"></span>a = *b;<br><span class=\"tab\"></span>*b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x = 1,y = 2;<br><span class=\"tab\"></span>sch(x,&y);<br><span class=\"tab\"></span>printf(\"%d\",x+y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valoare se va afişa pe ecran după executarea programului de mai sus?<br>",
    "answers": ["2", "1", "4", "3"],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) 2</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: o valoare \u00eentreag\u0103 <code>a</code> \u0219i un pointer la un \u00eentreg <code>*b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre <code>a</code> \u0219i valoarea indicat\u0103 de pointerul <code>*b</code>. Aceasta \u00eenseamn\u0103 c\u0103 valoarea lui <code>x</code> r\u0103m\u00e2ne neschimbat\u0103, dar valoarea lui <code>y</code> este actualizat\u0103 cu valoarea lui <code>x</code>.</li>\n<li>Ini\u021bial, <code>x = 1</code> \u0219i <code>y = 2</code>. Dup\u0103 apelul func\u021biei <code>sch(x,&y);</code>, <code>x</code> r\u0103m\u00e2ne 1 \u0219i <code>y</code> devine 1.</li>\n<li>Prin urmare, valoarea lui <code>x + y</code> va fi <code>1 + 1 = 2</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d\", x + y);</code> afi\u0219eaz\u0103 valoarea 2.</li>\n</ul>"
  },
  {
    "id": 12,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(char a, char *b) {<br><span class=\"tab\"></span>char aux;<br><span class=\"tab\"></span>aux = a;<br><span class=\"tab\"></span>a = *b;<br><span class=\"tab\"></span>*b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>char x = '1',y = '2';<br><span class=\"tab\"></span>sch(x,&y);<br><span class=\"tab\"></span>printf(\"%c,%c\",x,y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori se vor afişa pe ecran după executarea programului de mai sus?<br>",
    "answers": ["1,2", "2,1", "1,1", "2,2"],
    "correctAnswerIndexes": [2],
    "details":
      "<p>R\u0103spuns corect: <strong>a) 1,1</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: o valoare de tip <code>char</code> <code>a</code> \u0219i un pointer la un <code>char</code> <code>*b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre <code>a</code> \u0219i valoarea indicat\u0103 de pointerul <code>*b</code>. Aceasta \u00eenseamn\u0103 c\u0103 valoarea lui <code>a</code> devine valoarea lui <code>*b</code> \u0219i invers.</li>\n<li>Totu\u0219i, schimbarea valorii lui <code>a</code> nu afecteaz\u0103 valoarea lui <code>x</code> \u00een func\u021bia <code>main</code> deoarece <code>a</code> este o variabil\u0103 local\u0103 a func\u021biei <code>sch</code>.</li>\n<li>Astfel, doar valoarea indicat\u0103 de <code>*b</code>, adic\u0103 <code>y</code>, va fi schimbat\u0103 cu valoarea ini\u021bial\u0103 a lui <code>x</code>.</li>\n<li>Ini\u021bial, <code>x = '1'</code> \u0219i <code>y = '2'</code>. Dup\u0103 apelul func\u021biei <code>sch(x,&y);</code>, <code>x</code> r\u0103m\u00e2ne '1' \u0219i <code>y</code> devine '1'.</li>\n<li>Prin urmare, valoarea afi\u0219at\u0103 va fi <code>1,1</code>.</li>\n</ul>"

  },
  {
    "id": 13,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void sch(int *a, int b) {<br><span class=\"tab\"></span>int aux;<br><span class=\"tab\"></span>aux = *a;<br><span class=\"tab\"></span>*a = b;<br><span class=\"tab\"></span>b = aux;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x = 1,y = 2;<br><span class=\"tab\"></span>sch(&x,y);<br><span class=\"tab\"></span>printf(\"%d\",x*y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valoare se va afişa pe ecran după executarea programului de mai sus?<br>",
    "answers": ["3", "2", "4", "1"],
    "correctAnswerIndexes": [2],
    "details":
    "<p>R\u0103spuns corect: <strong>c) 4</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>sch</code> prime\u0219te doi parametri: un pointer la un \u00eentreg <code>*a</code> \u0219i un \u00eentreg <code>b</code>.</li>\n<li>\u00cen interiorul func\u021biei, se face schimbul valorilor dintre variabila indicat\u0103 de pointerul <code>*a</code> \u0219i valoarea lui <code>b</code>.</li>\n<li>Ini\u021bial, <code>x = 1</code> \u0219i <code>y = 2</code>. La apelul func\u021biei <code>sch(&x, y);</code>, valoarea lui <code>*a</code> (adic\u0103 <code>x</code>) devine valoarea lui <code>b</code>, care este 2.</li>\n<li>Totu\u0219i, schimbarea valorii lui <code>b</code> \u00een func\u021bia <code>sch</code> nu afecteaz\u0103 valoarea lui <code>y</code> \u00een func\u021bia <code>main</code> deoarece <code>b</code> este o variabil\u0103 local\u0103 a func\u021biei <code>sch</code>.</li>\n<li>Dup\u0103 apelul func\u021biei, <code>x</code> devine 2 \u0219i <code>y</code> r\u0103m\u00e2ne 2.</li>\n<li>Prin urmare, valoarea lui <code>x * y</code> va fi <code>2 * 2 = 4</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d\", x * y);</code> afi\u0219eaz\u0103 valoarea 4.</li>\n</ul>"

  },
  {
    "id": 14,
    "question": "<div class=\"code\">#include&lt;stdio.h&gt;<br>void f(int a,int *b) {<br><span class=\"tab\"></span>a++;<br><span class=\"tab\"></span>*b=a;<br><span class=\"tab\"></span>(*b)++;<br>}<br><br>void g(int *a,int b) {<br><span class=\"tab\"></span>b++;<br><span class=\"tab\"></span>*a=b;<br><span class=\"tab\"></span>(*a)++;<br>}<br><br>int main() {<br><span class=\"tab\"></span>int x=4, y=-2;<br><span class=\"tab\"></span>f(x,&y);<br><span class=\"tab\"></span>g(&x,y);<br><span class=\"tab\"></span>printf(\"%d %d\",x,y);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori se vor afişa pe ecran după executarea programului de mai sus?<br>",
    "answers": ["4 8", "8 8", "8 6", "6 6"],
    "correctAnswerIndexes": [2],
    "details":
      "<p>R\u0103spuns corect: <strong>c) 8 6</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>\u00cen func\u021bia <code>f</code>, <code>a</code> este incrementat, devenind 5. Apoi, valoarea lui <code>a</code> (5) este atribuit\u0103 variabilei indicate de <code>*b</code> (adic\u0103 <code>y</code>), deci <code>y</code> devine 5. \u00cen final, <code>(*b)++</code> incrementeaz\u0103 valoarea lui <code>y</code>, care devine 6.</li>\n<li>Deci, dup\u0103 apelul <code>f(x, &y)</code>, valorile sunt: <code>x = 4</code>, <code>y = 6</code>.</li>\n<li>\u00cen func\u021bia <code>g</code>, <code>b</code> este incrementat, devenind 7. Apoi, valoarea lui <code>b</code> (7) este atribuit\u0103 variabilei indicate de <code>*a</code> (adic\u0103 <code>x</code>), deci <code>x</code> devine 7. \u00cen final, <code>(*a)++</code> incrementeaz\u0103 valoarea lui <code>x</code>, care devine 8.</li>\n<li>Deci, dup\u0103 apelul <code>g(&x, y)</code>, valorile sunt: <code>x = 8</code>, <code>y = 6</code>.</li>\n<li>Instruc\u021biunea <code>printf(\"%d %d\", x, y);</code> afi\u0219eaz\u0103 valorile 8 \u0219i 6.</li>\n</ul>"

  },
  {
    "id": 15,
    "question": "Care dintre următoarele secvenţe de instrucţiuni atribuie variabilei de tip întreg 𝑚𝑎𝑥 cea mai mare valoare din tabloul 𝑎, format din 𝑛 numere întregi?<br>",
    "answers": [
      "<div class=\"code_2\">max=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;max) max=a[i];</div>",
      "<div class=\"code_2\">max=a[0];<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;a[i+1]) max=a[i];</div>",
      "<div class=\"code_2\">max=a[0];<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&gt;max) max=a[i];</div>",
      "<div class=\"code_2\">max=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(a[i]&lt;a[i+1]) max=a[i+1];</div>"
    ],
    "correctAnswerIndexes": [2],
    "details":
      "<p>Explicarea fiec\u0103rei op\u021biuni:<ol type=\"a\"><li>Aceast\u0103 secven\u021b\u0103 va func\u021biona corect doar dac\u0103 toate elementele din tabloul a sunt pozitive. \u00cen cazul \u00een care toate valorile sunt negative sau exist\u0103 valori negative care sunt mai mici dec\u00e2t zero (valoarea ini\u021bial\u0103 a max), atunci rezultatul va fi incorect, deoarece nicio valoare negativ\u0103 nu va fi mai mare dec\u00e2t 0.</li><li>Aceast\u0103 secven\u021b\u0103 este incorect\u0103 deoarece compara\u021bi fiecare element a[i] cu elementul urm\u0103tor a[i+1], \u0219i atribui\u021bi lui max valoarea a[i] doar dac\u0103 aceasta este mai mare dec\u00e2t a[i+1]. Acest algoritm nu garanteaz\u0103 g\u0103sirea celei mai mari valori din tablou, ci efectueaz\u0103 o verificare gre\u0219it\u0103 \u00eentre elementele consecutive.</li><li>Aceast\u0103 secven\u021b\u0103 \u00eencepe prin a seta max la prima valoare din tablou \u0219i apoi verific\u0103 fiecare element din tablou. Dac\u0103 un element a[i] este mai mare dec\u00e2t max curent, atunci max este actualizat cu acea valoare. Aceasta este metoda corect\u0103 de a determina cea mai mare valoare dintr-un tablou.</li><li>Aceast\u0103 secven\u021b\u0103 este incorect\u0103, deoarece compara\u021bia \u0219i atribuirea se fac \u00eentre elementele consecutive \u0219i max este setat la valoarea urm\u0103toare a[i+1] doar dac\u0103 este mai mare dec\u00e2t a[i]. Acesta nu este un mod adecvat de a g\u0103si maximul \u00eentr-un tablou, deoarece max nu va fi neap\u0103rat cea mai mare valoare din \u00eentregul tablou, ci doar \u00eentre perechile consecutive.</li></ol><p>R\u0103spuns corect: <strong>c) max=a[0];<br>for(i=0;i&lt;n;i++)<br>if(a[i]&gt;max) max=a[i];</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bializarea variabilei <code>max</code> cu prima valoare a tabloului <code>a[0]</code> asigur\u0103 c\u0103 orice valoare din tablou va fi comparat\u0103 corect.</li>\n<li>Buclele parcurg toate elementele tabloului de la 0 la <code>n-1</code>.</li>\n<li>Dac\u0103 elementul curent <code>a[i]</code> este mai mare dec\u00e2t valoarea curent\u0103 a lui <code>max</code>, atunci <code>max</code> este actualizat la <code>a[i]</code>.</li>\n<li>La finalul buclei, <code>max</code> va con\u021bine cea mai mare valoare din tablou.</li>\n</ul>\n<p>Exemplu de rulare pas cu pas:</p>\n<ol>\n<li>S\u0103 presupunem c\u0103 avem tabloul <code>a = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]</code> \u0219i <code>n = 11</code>.</li>\n<li>Ini\u021bial, <code>max = a[0] = 3</code>.</li>\n<li>Itera\u021biile buclei:</li>\n<ul>\n<li><code>i=0</code>, <code>a[0]=3</code>, <code>max=3</code> (nu se schimb\u0103)</li>\n<li><code>i=1</code>, <code>a[1]=1</code>, <code>max=3</code> (nu se schimb\u0103)</li>\n<li><code>i=2</code>, <code>a[2]=4</code>, <code>max=4</code> (se schimb\u0103)</li>\n<li><code>i=3</code>, <code>a[3]=1</code>, <code>max=4</code> (nu se schimb\u0103)</li>\n<li><code>i=4</code>, <code>a[4]=5</code>, <code>max=5</code> (se schimb\u0103)</li>\n<li><code>i=5</code>, <code>a[5]=9</code>, <code>max=9</code> (se schimb\u0103)</li>\n<li><code>i=6</code>, <code>a[6]=2</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=7</code>, <code>a[7]=6</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=8</code>, <code>a[8]=5</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=9</code>, <code>a[9]=3</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n<li><code>i=10</code>, <code>a[10]=5</code>, <code>max=9</code> (nu se schimb\u0103)</li>\n</ul>\n<li>La finalul buclei, <code>max</code> r\u0103m\u00e2ne 9, care este cea mai mare valoare din tablou.</li>\n</ol>\n<p><strong>Codul C pentru demonstra\u021bie:</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i, n, max;\n\n    // Citirea valorii lui n\n    printf(\"Introduce\u021bi num\u0103rul de elemente: \");\n    scanf(\"%d\", &n);\n\n    int a[n];  // Alocarea unui array de dimensiune n\n\n    // Citirea valorilor \u00een array-ul a\n    printf(\"Introduce\u021bi elementele: \\n\");\n    for(i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n    }\n    // Ini\u021bializarea lui max cu primul element din array\n    // si \u00cencepem de la 1 deoarece max este deja ini\u021bializat cu a[0]\n    max=a[0];\n    for(i=0;i&lt;n;i++)\n        if(a[i]&gt;max) max=a[i];\n\n    printf(\"Valoarea maxim\u0103 este: %d\\n\", max);\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 16,
    "question": "<div class=\"code\">np=0;<br>for(i=0;i&lt;n;i++)<br><span class=\"tab\"></span>if(…) np++;<br>printf(\"%d\",np);</div><br><br>Cu ce expresie dintre cele de mai jos trebuie înlocuite spaţiile punctate din secvenţă de instrucțiuni dată astfel încât aceasta să afişeze câte valori strict pozitive şi pare sunt în tabloul 𝑎, format din 𝑛 numere întregi?<br>",
    "answers": [
      "<div class=\"code_2\">(a[i]&gt;0)&&(a[i]%2!=0)</div>",
      "<div class=\"code_2\">(a[i]&gt;0)&&(a[i]%2==0)</div>",
      "<div class=\"code_2\">(a[i]&gt;0)||(a[i]%2!=0)</div>",
      "<div class=\"code_2\">(a[i]&gt;=0)||(a[i]%2==0)</div>"
    ],
    "correctAnswerIndexes": [1],
    "details":
      "<p>R\u0103spuns corect: <strong>b) (a[i]>0)&&(a[i]%2==0)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Expresia <code>(a[i]>0)</code> verific\u0103 dac\u0103 elementul din tablou este strict pozitiv.</li>\n<li>Expresia <code>(a[i]%2==0)</code> verific\u0103 dac\u0103 elementul din tablou este par.</li>\n<li>Combina\u021bia logic\u0103 <code>(a[i]>0)&&(a[i]%2==0)</code> asigur\u0103 c\u0103 elementul este at\u00e2t pozitiv, c\u00e2t \u0219i par.</li>\n<li>Astfel, variabila <code>np</code> va fi incrementat\u0103 doar pentru elementele strict pozitive \u0219i pare.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i, n, np = 0;\n\n    // Citirea valorii lui n\n    printf(\"Introduce\u021bi num\u0103rul de elemente: \");\n    scanf(\"%d\", &n);\n\n    int a[n];  // Alocarea unui array de dimensiune n\n\n    // Citirea valorilor \u00een array-ul a\n    printf(\"Introduce\u021bi elementele: \\n\");\n    for(i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // Num\u0103rarea valorilor strict pozitive \u0219i pare\n    for(i = 0; i < n; i++) {\n        if((a[i]>0) && (a[i]%2==0)) {\n            np++;\n        }\n    }\n\n    // Afi\u0219area rezultatului\n    printf(\"Num\u0103rul de elemente strict pozitive \u0219i pare: %d\\n\", np);\n    return 0;\n}\n</code></pre>"
 
  },
  {
    "id": 17,
    "question": "Care este valoarea expresiei?<br><br><div class=\"code\">strlen(\"programare\")+strcmp(\"test\",\"test\")</div><br><br>",
    "answers": ["10", "14", "18", "\"programaretesttest\""],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) 10</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>strlen(\"programare\")</code> calculeaz\u0103 lungimea \u0219irului de caractere \"programare\". Lungimea acestui \u0219ir este 10 caractere.</li>\n<li>Func\u021bia <code>strcmp(\"test\", \"test\")</code> compar\u0103 cele dou\u0103 \u0219iruri de caractere \"test\" \u0219i \"test\". Deoarece cele dou\u0103 \u0219iruri sunt identice, <code>strcmp</code> va returna 0.</li>\n<li>Prin urmare, valoarea expresiei <code>strlen(\"programare\") + strcmp(\"test\", \"test\")</code> va fi <code>10 + 0</code>, adic\u0103 10.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    int result;\n    result = strlen(\"programare\") + strcmp(\"test\", \"test\");\n    printf(\"%d\\n\", result);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 18,
    "question": "<div class=\"code\">char s[100];<br>strcpy(s,\"\");<br>strcat(s,\"abcdefgh\");<br>strcpy(s+2,s+4);<br>printf(\"%s %d\" ,s,strlen(s));</div><br><br>Ce se va afişa pe ecran după executarea secvenţei date?<br>",
    "answers": ["adefgh 6", "abefgh 6", "abfgh 5", "abefgh 8"],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) abefgh 6</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este declarat cu 100 de caractere.</li>\n<li><code>strcpy(s, \"\");</code> ini\u021bializeaz\u0103 \u0219irul <code>s</code> cu \u0219irul vid.</li>\n<li><code>strcat(s, \"abcdefgh\");</code> concateneaz\u0103 \u0219irul \"abcdefgh\" la \u0219irul <code>s</code>, rezult\u00e2nd <code>s = \"abcdefgh\"</code>.</li>\n<li><code>strcpy(s+2, s+4);</code> copiaz\u0103 \u0219irul \u00eencep\u00e2nd de la indexul 4 (care este \"e\") la indexul 2, rezult\u00e2nd <code>s = \"abefgh\"</code>.</li>\n<li>\u00cen final, <code>printf(\"%s %d\", s, strlen(s));</code> afi\u0219eaz\u0103 \u0219irul <code>s</code> \u0219i lungimea acestuia.</li>\n<li>Lungimea \u0219irului <code>abefgh</code> este 6.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[100];\n    strcpy(s, \"\");\n    strcat(s, \"abcdefgh\");\n    strcpy(s+2, s+4);\n\t//Conversia valorii returnate de strlen la int pentru eliminarea avertiz\u0103rilor\n    printf(\"%s %d\\n\", s, (int)strlen(s));  // Afi\u0219eaz\u0103 \u0219irul \u0219i lungimea acestuia\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 19,
    "question": "Care din următoarele expresii de tip logic este adevărată (are o valoare nenulă) dacă şi numai dacă şirul de caractere 𝑠, de lungime 10, este obţinut prin concatenarea a două şiruri identice?<br>",
    "answers": [
      "<div class=\"code_2\">strcmp(s,s+5)==0</div>",
      "<div class=\"code_2\">s==strstr(s,s+5)</div>",
      "<div class=\"code_2\">s==s+5</div>",
      "<div class=\"code_2\">strcmp(s,strcat(s,s+5))==0</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) s==strstr(s,s+5)</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>strstr(s, s+5)</code> caut\u0103 \u0219irul <code>s+5</code> \u00een \u0219irul <code>s</code>.</li>\n<li>Dac\u0103 \u0219irul <code>s+5</code> este g\u0103sit \u00een \u0219irul <code>s</code>, atunci func\u021bia va returna un pointer la loca\u021bia unde \u0219irul a fost g\u0103sit.</li>\n<li>Dac\u0103 cele dou\u0103 \u0219iruri sunt identice, atunci pointerul returnat va fi egal cu pointerul c\u0103tre \u0219irul <code>s</code>.</li>\n<li>Prin urmare, expresia <code>s == strstr(s, s+5)</code> va fi adev\u0103rat\u0103 doar dac\u0103 \u0219irul <code>s</code> este ob\u021binut prin concatenarea a dou\u0103 \u0219iruri identice.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[10];\n    // Ini\u021bializarea \u0219irului s\n    strcpy(s, \"testtest\");\n\n    // Verificarea dac\u0103 s este ob\u021binut prin concatenarea a dou\u0103 \u0219iruri identice\n    if(s == strstr(s, s+5)) {\n        printf(\"Adev\u0103rat\");\n    } else {\n        printf(\"Fals\");\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 20,
    "question": "Considerăm următoarea secvenţă de instrucțiuni:<br><br><div class=\"code\">char s[]=\"abcdabcd\",c = 'c';<br>char *p = strchr(s,c);<br>printf(\"%d\",p - s);</div><br><br>Ce se va afişa pe ecran după executarea secvenţei date?<br>",
    "answers": ["cdabcd", "6", "cd", "2"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) 2</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code> \u0219i caracterul <code>c</code> este definit ca <code>'c'</code>.</li>\n<li>Func\u021bia <code>strchr(s, c)</code> caut\u0103 prima apari\u021bie a caracterului <code>c</code> \u00een \u0219irul <code>s</code>.</li>\n<li>Dac\u0103 caracterul este g\u0103sit, func\u021bia returneaz\u0103 un pointer la loca\u021bia caracterului \u00een \u0219irul <code>s</code>.</li>\n<li>Deoarece caracterul <code>'c'</code> este g\u0103sit la indexul 2 \u00een \u0219irul <code>s</code>, pointerul <code>p</code> va con\u021bine adresa acestui caracter.</li>\n<li>Prin urmare, diferen\u021ba dintre pointerul <code>p</code> \u0219i pointerul c\u0103tre \u0219irul <code>s</code> va fi 2, deoarece caracterul <code>'c'</code> se afl\u0103 la indexul 2 \u00een \u0219irul <code>s</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[] = \"abcdabcd\", c = 'c';\n    char *p = strchr(s, c);\n    printf(\"%d\", p - s);  // Afi\u0219eaz\u0103 diferen\u021ba dintre pointeri\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 21,
    "question": "Considerăm următoarea secvenţă de instrucțiuni:<br><br><div class=\"code\">char s[20];<br>strcpy(s,\"abcdabcd\");<br>strncat(s,s+2,3);<br>strcpy(s,s+4);<br>printf(\"%d\",strlen(s));</div><br><br>Ce se va afişa pe ecran după executarea secvenţei date?<br>",
    "answers": ["6", "10", "9", "7"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) 7</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code>.</li>\n<li><code>strncat(s, s+2, 3)</code> concateneaz\u0103 primele 3 caractere de la indexul 2 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdabcdab\"</code>.</li>\n<li><code>strcpy(s, s+4)</code> copiaz\u0103 \u0219irul de la indexul 4 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdabcdababcd\"</code>.</li>\n<li>Prin urmare, lungimea \u0219irului <code>s</code> va fi 7, deoarece con\u021bine 7 caractere.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[20];\n    strcpy(s, \"abcdabcd\");\n    strncat(s, s+2, 3);\n    strcpy(s, s+4);\n    printf(\"%d\", strlen(s));  // Afi\u0219eaz\u0103 lungimea \u0219irului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 22,
    "question": "Considerăm următoarea secvenţă de instrucțiuni:<br><br><div class=\"code\">char s[20];<br>strncpy(s,\"abcdabcd\",6);<br>s[6]='\\0';<br>strcat(s,s+4);<br>strcpy(s+3,s+6);<br>printf(\"%s\",s);</div><br><br>Ce se va afişa pe ecran după executarea secvenţei date?<br>",
    "answers": ["abcabab", "abcdab", "abcab", "abcdabd"],
    "correctAnswerIndexes": [2],
    "details": "<p>R\u0103spuns corect: <strong>c) abcab</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Ini\u021bial, \u0219irul <code>s</code> este definit ca <code>\"abcdabcd\"</code>.</li>\n<li><code>strncpy(s, \"abcdabcd\", 6)</code> copiaz\u0103 primele 6 caractere din \u0219irul <code>\"abcdabcd\"</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcdab\"</code>.</li>\n<li><code>s[6] = '\\0'</code> adaug\u0103 terminatorul de \u0219ir la indexul 6, astfel \u00eencât \u0219irul <code>s</code> s\u0103 aib\u0103 o lungime de 6 caractere.</li>\n<li><code>strcat(s, s+4)</code> concateneaz\u0103 \u0219irul de la indexul 4 din <code>s</code> la \u0219irul <code>s</code>. \u0218irul rezultat va fi <code>\"abcab\"</code>.</li>\n<li><code>strcpy(s+3, s+6)</code> copiaz\u0103 \u0219irul de la indexul 6 din <code>s</code> la indexul 3 din <code>s</code>. \u0218irul rezultat va fi <code>\"abcab\"</code>.</li>\n<li>Prin urmare, \u0219irul rezultat va fi <code>\"abcab\"</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char s[20];\n    strncpy(s, \"abcdabcd\", 6);\n    s[6] = '\\0';\n    strcat(s, s+4); // Concatenarea \u0219irului de la indexul 4\n    strcpy(s+3, s+6);  // Copierea \u0219irului de la indexul 6 la indexul 3\n    printf(\"%s\", s);  // Afi\u0219eaz\u0103 \u0219irul rezultat\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 23,
    "question": "Considerăm următoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int zi,luna,an;<br>}Data;<br><br>typedef struct {<br><span class=\"tab\"></span>char nume[30];<br><span class=\"tab\"></span>Data data_nasterii;<br><span class=\"tab\"></span>float media;<br>}Student;</div><br><br>Știind că variabila st este de tip Student, indicați instrucţiunea de mai jos prin care luna<br>naşterii studentului respectiv primește valoarea 12:<br>",
    "answers": [
      "<div class=\"code_2\">st-&gt;data_nasterii-&gt;luna=12;</div>",
      "<div class=\"code_2\">st.data_nasterii.luna=12;</div>",
      "<div class=\"code_2\">data_nasterii.luna=12;</div>",
      "<div class=\"code_2\">st.luna=12;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) st.data_nasterii.luna=12</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>st</code> este de tip <code>Student</code>, trebuie s\u0103 acces\u0103m campul <code>luna</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>st->data_nasterii->luna=12;</code> este incorect\u0103 deoarece <code>st</code> este o variabil\u0103 de tip <code>Student</code>, nu un pointer c\u0103tre <code>Student</code>. Accesarea cu <code>-></code> este incorect\u0103 \u00een acest context.</li>\n<li><strong>Op\u021biunea b)</strong> <code>st.data_nasterii.luna=12;</code> este corect\u0103 deoarece acceseaz\u0103 direct campul <code>luna</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>data_nasterii.luna=12;</code> este incorect\u0103 deoarece <code>data_nasterii</code> nu este o variabil\u0103 accesibil\u0103 direct, ci un camp al variabilei <code>st</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>st.luna=12;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze un camp <code>luna</code> care nu exist\u0103 direct \u00een structura <code>Student</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n\nint main() {\n    Student st;\n    st.data_nasterii.luna = 12;\n    printf(\"Luna nasterii: %d\\n\", st.data_nasterii.luna);  // Afi\u0219eaz\u0103 luna na\u0219terii\n    return 0;\n}\n</code></pre>"

  },
  {
    "id": 24,
    "question": "Considerăm următoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int zi,luna,an;<br>}Data;<br><br>typedef struct {<br><span class=\"tab\"></span>char nume[30];<br><span class=\"tab\"></span>Data data_nasterii;<br><span class=\"tab\"></span>float media;<br>}Student;</div><br><br>Știind că variabila st este de tip Student, indicați instrucţiunea de mai jos prin care anul<br>naşterii studentului respectiv primește valoarea 1990:<br>",
    "answers": [
      "<div class=\"code_2\">st-&gt;data_nasterii-&gt;an=1990;</div>",
      "<div class=\"code_2\">st.data_nasterii.an=1990;</div>",
      "<div class=\"code_2\">data_nasterii.an=1990;</div>",
      "<div class=\"code_2\">st.an=1990;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details":
      "<p>R\u0103spuns corect: <strong>b) st.data_nasterii.an=1990</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>st</code> este de tip <code>Student</code>, trebuie s\u0103 acces\u0103m campul <code>an</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>st->data_nasterii->an=1990;</code> este incorect\u0103 deoarece <code>st</code> este o variabil\u0103 de tip <code>Student</code>, nu un pointer c\u0103tre <code>Student</code>. Accesarea cu <code>-&gt;</code> este incorect\u0103 \u00een acest context.</li>\n<li><strong>Op\u021biunea b)</strong> <code>st.data_nasterii.an=1990;</code> este corect\u0103 deoarece acceseaz\u0103 direct campul <code>an</code> din structura <code>data_nasterii</code> din structura <code>Student</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>data_nasterii.an=1990;</code> este incorect\u0103 deoarece <code>data_nasterii</code> nu este o variabil\u0103 accesibil\u0103 direct, ci un camp al variabilei <code>st</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>st.an=1990;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze un camp <code>an</code> care nu exist\u0103 direct \u00een structura <code>Student</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int zi, luna, an;\n} Data;\n\ntypedef struct {\n    char nume[30];\n    Data data_nasterii;\n    float media;\n} Student;\n\nint main() {\n    Student st;\n    st.data_nasterii.an = 1990;\n    printf(\"Anul nasterii: %d\\n\", st.data_nasterii.an);  // Afi\u0219eaz\u0103 anul na\u0219terii\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 25,
    "question": "Considerăm următoarele structuri:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>int x,y;<br>}Punct_2D;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct_2D p;<br><span class=\"tab\"></span>int z;<br>}Punct_3D;</div><br><br>Știind că variabila a este de tip Punct_3D, fiind folosită pentru a stoca coordonatele unui punct<br>în spațiu, indicați instrucţiunea de mai jos prin care toate cele 3 coordonate ale punctului a se iniţializează cu valoarea 0:<br>",
    "answers": [
      "<div class=\"code_2\">a.p.x = a.p.y = a.p.z = 0;</div>",
      "<div class=\"code_2\">a.p.x = a.p.y = a.z = 0;</div>",
      "<div class=\"code_2\">a.x = a.y = a.z = 0;</div>",
      "<div class=\"code_2\">a.p = a.z = 0;</div>"
    ],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>a) a.p.x = a.p.y = a.z = 0;</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    int x, y;\n} Punct_2D;\n\ntypedef struct {\n    Punct_2D p;\n    int z;\n} Punct_3D;\n</code></pre>\n<li>\u0218tiind c\u0103 variabila <code>a</code> este de tip <code>Punct_3D</code>, trebuie s\u0103 acces\u0103m toate cele 3 coordonate ale punctului <code>a</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>a.p.x = a.p.y = a.z = 0;</code> este corect\u0103 deoarece acceseaz\u0103 direct coordonatele <code>x</code> \u0219i <code>y</code> ale punctului <code>a</code> \u0219i coordonata <code>z</code> a punctului <code>a</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>a.p.x = a.p.y = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze coordonata <code>z</code> a punctului <code>a</code> folosind <code>a.p</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>a.x = a.y = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze coordonatele <code>x</code>, <code>y</code> \u0219i <code>z</code> ale punctului <code>a</code> folosind <code>a</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>a.p = a.z = 0;</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 atribuie valoarea 0 variabilei <code>a.p</code>, care este de tip <code>Punct_2D</code>, nu unui intreg.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int x, y;\n} Punct_2D;\n\ntypedef struct {\n    Punct_2D p;\n    int z;\n} Punct_3D;\n\nint main() {\n    Punct_3D a;\n    a.p.x = a.p.y = a.z = 0;\n    printf(\"Coordonatele: (%d, %d, %d)\\n\", a.p.x, a.p.y, a.z);  // Afi\u0219eaz\u0103 coordonatele\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 26,
    "question": "Considerăm tipul de date Punct, capabil să memoreze abscisa şi ordonata unui punct din plan, şi tipul de date Segment, capabil să memoreze două puncte reprezentând extremităţile unui segment din plan, definite astfel:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>float x,y;<br>}Punct;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct A,B;<br>}Segment;</div><br><br>Care dintre următoarele expresii are o valoare nenulă dacă şi numai dacă variabila 𝑠 de tip Segment memorează informații despre un segment vertical (aflat pe axa Oy sau paralel cu axa Oy)?<br>",
    "answers": ["s.A == s.B", "s.x == s.y", "A.x == B.x", "s.A.x == s.B.x"],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) s.A.x == s.B.x</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n</code></pre>\n<li>\u0218tim c\u0103 un segment vertical este definit de dou\u0103 puncte cu aceea\u0219i abscis\u0103, dar cu ordonate diferite.</li>\n<li>Prin urmare, pentru a verifica dac\u0103 un segment este vertical, putem compara abscisele celor dou\u0103 puncte ale segmentului.</li>\n<li><strong>Op\u021biunea a)</strong> <code>s.A == s.B</code> este incorect\u0103 deoarece compar\u0103 adresele celor dou\u0103 puncte ale segmentului, nu valorile acestora.</li>\n<li><strong>Op\u021biunea b)</strong> <code>s.x == s.y</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze c\u00e2mpurile <code>x</code> \u0219i <code>y</code> ale segmentului, care nu exist\u0103 direct.</li>\n<li><strong>Op\u021biunea c)</strong> <code>A.x == B.x</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 acceseze c\u00e2mpurile <code>x</code> ale punctelor <code>A</code> \u0219i <code>B</code> ale segmentului, care nu exist\u0103 direct.</li>\n<li><strong>Op\u021biunea d)</strong> <code>s.A.x == s.B.x</code> este corect\u0103 deoarece compar\u0103 abscisele celor dou\u0103 puncte ale segmentului, determin\u00e2nd dac\u0103 segmentul este vertical sau nu.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n\nint main() {\n    Segment s;\n    s.A.x = 1;\n    s.A.y = 2;\n    s.B.x = 1;\n    s.B.y = 3;\n    if(s.A.x == s.B.x) {\n        printf(\"Segmentul este vertical\");\n    } else {\n        printf(\"Segmentul nu este vertical\");\n    }\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 27,
    "question": "Considerăm tipul de date Punct, capabil să memoreze abscisa şi ordonata unui punct din plan, şi tipul de date Segment, capabil să memoreze două puncte reprezentând extremităţile unui segment din plan, definite astfel:<br><br><div class=\"code\">typedef struct {<br><span class=\"tab\"></span>float x,y;<br>}Punct;<br><br>typedef struct {<br><span class=\"tab\"></span>Punct A,B;<br>}Segment;</div><br><br>Care dintre următoarele funcții returnează lungimea segmentului transmis prin intermediul parametrului s de tip Segment?<br>",
    "answers": [
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return pow(s.A.x–s.B.x,2)+pow(s.A.y–s.B.y,2);<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return sqrt((s.A.x–s.B.x)+(s.A.y–s.B.y));<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return s.B-s.A;<br>}</div>",
      "<div class=\"code_2\">double f(Segment s) {<br><span class=\"tab\"></span>return sqrt(pow(s.A.x–s.B.x,2)+pow(s.A.y–s.B.y,2));<br>}</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) double f(Segment s) { return sqrt(pow(s.A.x–s.B.x,2)+pow(s.A.y–s.B.y,2)); }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Structurile definite sunt:</li>\n<pre><code>typedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n</code></pre>\n<li>Func\u021bia <code>f</code> prime\u0219te un segment <code>s</code> ca parametru \u0219i returneaz\u0103 lungimea segmentului.</li>\n<li>Formula pentru calcularea lungimii unui segment \u00een plan este distan\u021ba euclidian\u0103 dintre cele dou\u0103 puncte care definesc segmentul.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 calculeze distan\u021ba euclidian\u0103 dintre punctele <code>A</code> \u0219i <code>B</code> ale segmentului <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>double f(Segment s) { return pow(s.A.x–s.B.x,2)+pow(s.A.y–s.B.y,2); }</code> este incorect\u0103 deoarece calculeaz\u0103 p\u0103tratul distan\u021bei euclidiene, nu distan\u021ba euclidian\u0103 \u00een sine.</li>\n<li><strong>Op\u021biunea b)</strong> <code>double f(Segment s) { return sqrt((s.A.x–s.B.x)+(s.A.y–s.B.y)); }</code> este incorect\u0103 deoarece calculeaz\u0103 suma diferen\u021belor dintre abscisele \u0219i ordonatele punctelor, nu distan\u021ba euclidian\u0103.</li>\n<li><strong>Op\u021biunea c)</strong> <code>double f(Segment s) { return s.B-s.A; }</code> este incorect\u0103 deoarece \u00eencearc\u0103 s\u0103 scad\u0103 dou\u0103 structuri de tip <code>Punct</code>, care nu este permis.</li>\n<li><strong>Op\u021biunea d)</strong> <code>double f(Segment s) { return sqrt(pow(s.A.x–s.B.x,2)+pow(s.A.y–s.B.y,2)); }</code> este corect\u0103 deoarece calculeaz\u0103 distan\u021ba euclidian\u0103 dintre punctele <code>A</code> \u0219i <code>B</code> ale segmentului <code>s</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;math.h>\n\ntypedef struct {\n    float x, y;\n} Punct;\n\ntypedef struct {\n    Punct A, B;\n} Segment;\n\ndouble f(Segment s) {\n    return sqrt(pow(s.A.x–s.B.x, 2) + pow(s.A.y–s.B.y, 2));\n}\n\nint main() {\n    Segment s;\n    s.A.x = 1;\n    s.A.y = 2;\n    s.B.x = 4;\n    s.B.y = 6;\n    printf(\"Lungimea segmentului: %f\\n\", f(s));  // Afi\u0219eaz\u0103 lungimea segmentului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 28,
    "question": "Considerăm funcția <div class=\"code\">int suma(int x,int y)</div> care returnează suma numerelor întregi x și y, precum și funcția <div class=\"code\">int prod(int x,int y)</div> care returnează produsul numerelor întregi x și y. Știind că a, b și c sunt 3 variabile de tip întreg, care dintre expresiile de mai jos atribuie variabilei t de tip întreg valoarea expresiei <div class=\"code\">(a+b)*(a+c)+b*c</div><br>",
    "answers": [
      "<div class=\"code_2\">t = prod(suma(a,b),suma(a,c),prod(b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(suma(a,b),suma(a,c)),suma(b,c));</div>",
      "<div class=\"code_2\">t = prod(suma(a,b),suma(a,c)+suma(b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(suma(a,b),suma(a,c)),prod(b,c));</div>"
    ],
    "correctAnswerIndexes": [3],
    "details": "<p>R\u0103spuns corect: <strong>d) t = suma(prod(suma(a,b),suma(a,c)),prod(b,c));</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 suma lor.</li>\n<li>Func\u021bia <code>prod</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 produsul lor.</li>\n<li>Expresia <code>(a+b)*(a+c)+b*c</code> reprezint\u0103 suma produsului dintre <code>a+b</code> \u0219i <code>a+c</code> \u0219i produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n<li>Prin urmare, pentru a atribui valoarea expresiei variabilei <code>t</code>, trebuie s\u0103 calcul\u0103m produsul dintre suma dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, apoi s\u0103 ad\u0103ug\u0103m produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>t = prod(suma(a,b), suma(a,c), prod(b,c));</code> este incorect\u0103 deoarece func\u021bia <code>prod</code> prime\u0219te doar dou\u0103 argumente, nu trei.</li>\n<li><strong>Op\u021biunea b)</strong> <code>t = suma(prod(suma(a,b), suma(a,c)), suma(b,c));</code> este incorect\u0103 deoarece adun\u0103 suma produsului dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, nu produsul acestora.</li>\n<li><strong>Op\u021biunea c)</strong> <code>t = prod(suma(a,b), suma(a,c) + suma(b,c));</code> este incorect\u0103 deoarece adun\u0103 suma dintre <code>a</code> \u0219i <code>c</code> \u0219i suma dintre <code>b</code> \u0219i <code>c</code>, nu produsul acestora.</li>\n<li><strong>Op\u021biunea d)</strong> <code>t = suma(prod(suma(a,b), suma(a,c)), prod(b,c));</code> este corect\u0103 deoarece calculeaz\u0103 suma produsului dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre <code>a</code> \u0219i <code>c</code>, apoi adaug\u0103 produsul dintre <code>b</code> \u0219i <code>c</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int x, int y) {\n    return x + y;\n}\n\nint prod(int x, int y) {\n    return x * y;\n}\n\nint main() {\n    int a = 1, b = 2, c = 3;\n    int t = suma(prod(suma(a, b), suma(a, c)), prod(b, c));\n    printf(\"Valoarea expresiei: %d\\n\", t);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 29,
    "question": "Considerăm funcția <div class=\"code\">int suma(int x,int y)</div> care returnează suma numerelor întregi x și y, precum și funcția <div class=\"code\">int prod(int x,int y)</div> care returnează produsul numerelor întregi x și y. Știind că a, b și c sunt 3 variabile de tip întreg, care dintre expresiile de mai jos atribuie variabilei t de tip întreg valoarea expresiei <div class=\"code\">a*b+a*b*c</div><br>",
    "answers": [
      "<div class=\"code_2\">t = suma(prod(a,b),prod(a,b+c));</div>",
      "<div class=\"code_2\">t = suma(prod(a,b),prod(a,b,c));</div>",
      "<div class=\"code_2\">t = suma(prod(a,b),prod(prod(a,b),c));</div>",
      "<div class=\"code_2\">t = prod(prod(a,b),suma(1,c));</div>"
    ],
    "correctAnswerIndexes": [2, 3],
    "details": "<p>R\u0103spuns corect: <strong>c) t = suma(prod(a,b), prod(prod(a,b), c));</strong> \u0219i <strong>d) t = prod(prod(a,b), suma(1, c));</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 suma lor.</li>\n<li>Func\u021bia <code>prod</code> prime\u0219te dou\u0103 numere \u00eentregi <code>x</code> \u0219i <code>y</code> \u0219i returneaz\u0103 produsul lor.</li>\n<li>Expresia <code>a*b+a*b*c</code> reprezint\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li>Prin urmare, pentru a atribui valoarea expresiei variabilei <code>t</code>, trebuie s\u0103 calcul\u0103m produsul dintre <code>a</code> \u0219i <code>b</code>, apoi s\u0103 ad\u0103ug\u0103m produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>t = suma(prod(a,b), prod(a,b+c));</code> este incorect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre <code>a</code> \u0219i <code>b+c</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>t = suma(prod(a,b), prod(a,b,c));</code> este incorect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre <code>a</code>, <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea c)</strong> <code>t = suma(prod(a,b), prod(prod(a,b), c));</code> este corect\u0103 deoarece calculeaz\u0103 suma dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i <code>c</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>t = prod(prod(a,b), suma(1, c));</code> este corect\u0103 deoarece calculeaz\u0103 produsul dintre produsul dintre <code>a</code> \u0219i <code>b</code> \u0219i suma dintre 1 \u0219i <code>c</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int x, int y) {\n    return x + y;\n}\n\nint prod(int x, int y) {\n    return x * y;\n}\n\nint main() {\n    int a = 1, b = 2, c = 3;\n    int t = suma(prod(a, b), prod(prod(a, b), c));\n    printf(\"Valoarea expresiei: %d\\n\", t);  // Afi\u0219eaz\u0103 valoarea expresiei\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 30,
    "question": "Care dintre următoarele funcții returnează suma cifrelor numărului natural n?",
    "answers": [
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n/10;<br><span class=\"tab_2\"></span>n=n%10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=s+n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int f(int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>while(n!=0) {<br><span class=\"tab_2\"></span>s=n%10;<br><span class=\"tab_2\"></span>n=n/10;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>return s;<br>}</div>"
    ],
    "correctAnswerIndexes": [0],
    "details": "<p>R\u0103spuns corect: <strong>a) int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } return s; }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>f</code> prime\u0219te un num\u0103r natural <code>n</code> ca parametru \u0219i returneaz\u0103 suma cifrelor acestuia.</li>\n<li>Algoritmul pentru calcularea sumei cifrelor unui num\u0103r este de a parcurge cifrele num\u0103rului \u0219i de a le aduna \u00eentr-o variabil\u0103 auxiliar\u0103.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 parcurg\u0103 cifrele num\u0103rului \u0219i s\u0103 le adune \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } return s; }</code> este corect\u0103 deoarece parcurge cifrele num\u0103rului <code>n</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n/10; n=n%10; } return s; }</code> este incorect\u0103 deoarece adun\u0103 cifra unit\u0103\u021bilor la suma, nu cifra curent\u0103.</li>\n<li><strong>Op\u021biunea c)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=s+n%10; n=n/10; } }</code> este incorect\u0103 deoarece nu returneaz\u0103 suma cifrelor num\u0103rului.</li>\n<li><strong>Op\u021biunea d)</strong> <code>int f(int n) { int s=0; while(n!=0) { s=n%10; n=n/10; } return s; }</code> este incorect\u0103 deoarece atribuie cifra curent\u0103 variabilei <code>s</code>, nu o adun\u0103 la suma.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint f(int n) {\n    int s = 0;\n    while(n != 0) {\n        s = s + n % 10;\n        n = n / 10;\n    }\n    return s;\n}\n\nint main() {\n    int n = 12345;\n    printf(\"Suma cifrelor: %d\\n\", f(n));  // Afi\u0219eaz\u0103 suma cifrelor\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 31,
    "question": "Care dintre următoarele funcții poate fi folosită într-un program pentru a citi de la tastatură un<br>tablou unidimensional format din numere întregi?",
    "answers": [
      "<div class=\"code_2\">void citire(int v[],int n) {<br><span class=\"tab\"></span>scanf(\"%d\",&n);<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int v[],int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",n);<br><span class=\"tab\"></span>for(int i=0;i&lt;*n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int *v[],int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",&n);<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++) scanf(\"%d\",&v[i]);<br>}</div>",
      "<div class=\"code_2\">void citire(int *v,int *n) {<br><span class=\"tab\"></span>scanf(\"%d\",n);<br><span class=\"tab\"></span>for(int i=0;i&lt;*n;i++) scanf(\"%d\",v+i);<br>}</div>"
    ],
    "correctAnswerIndexes": [1, 3],
    "details": "<p>R\u0103spuns corect: <strong>b) void citire(int v[], int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", &v[i]); }</strong> \u0219i <strong>d) void citire(int *v, int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", v + i); }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>citire</code> prime\u0219te un tablou unidimensional <code>v</code> \u0219i un num\u0103r <code>n</code> de elemente \u0219i cite\u0219te valorile acestuia de la tastatur\u0103.</li>\n<li>Parametrul <code>n</code> este transmis prin referin\u021b\u0103 pentru a actualiza num\u0103rul de elemente citite.</li>\n<li>Algoritmul pentru citirea unui tablou unidimensional este de a citi num\u0103rul de elemente, apoi de a citi fiecare element \u00een parte.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 citeasc\u0103 num\u0103rul de elemente \u0219i apoi s\u0103 citeasc\u0103 fiecare element \u00een parte.</li>\n<li><strong>Op\u021biunea a)</strong> <code>void citire(int v[], int n) { scanf(\"%d\", &n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &v[i]); }</code> este incorect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u00eenainte de a citi elementele, ceea ce poate duce la erori.</li>\n<li><strong>Op\u021biunea b)</strong> <code>void citire(int v[], int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", &v[i]); }</code> este corect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u0219i apoi cite\u0219te fiecare element \u00een parte.</li>\n<li><strong>Op\u021biunea c)</strong> <code>void citire(int *v[], int *n) { scanf(\"%d\", &n); for(int i = 0; i &lt; n; i++) scanf(\"%d\", &v[i]); }</code> este incorect\u0103 deoarece transmite un pointer la un tablou de pointeri, nu un tablou unidimensional.</li>\n<li><strong>Op\u021biunea d)</strong> <code>void citire(int *v, int *n) { scanf(\"%d\", n); for(int i = 0; i &lt; *n; i++) scanf(\"%d\", v + i); }</code> este corect\u0103 deoarece cite\u0219te num\u0103rul de elemente \u0219i apoi cite\u0219te fiecare element \u00een parte folosind aritmetica pointerilor.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid citire(int v[], int *n) {\n    scanf(\"%d\", n);\n    for(int i = 0; i &lt; *n; i++)\n        scanf(\"%d\", &v[i]);\n}\n\nint main() {\n    int v[100], n;\n    citire(v, &n);  // Cite\u0219te un tablou unidimensional\n    for(int i = 0; i &lt; n; i++)\n        printf(\"%d \", v[i]);  // Afi\u0219eaz\u0103 elementele tabloului\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 32,
    "question": "Care dintre următoarele funcții returnează suma elementelor tabloului unidimensional de<br>numere întregi transmis ca parametru?",
    "answers": [
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0,k=0;<br><span class=\"tab\"></span>while(k&lt;n) s+=v[k++];<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0,k=0;<br><span class=\"tab\"></span>while(k++&lt;n) s+=v[k];<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s,k;<br><span class=\"tab\"></span>for(k=s=0;k&lt;n;s+=v[k++]);<br><span class=\"tab\"></span>return s;<br>}</div>",
      "<div class=\"code_2\">int suma(int v[],int n) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int k=n-1;k&gt;=0;k--) s+=v[n-k-1];<br><span class=\"tab\"></span>return s;<br>}</div>"
    ],
    "correctAnswerIndexes": [0, 2, 3],
    "details": "<p>R\u0103spuns corect: <strong>a) int suma(int v[], int n) { int s = 0, k = 0; while(k &lt; n) s += v[k++]; return s; }</strong>, <strong>c) int suma(int v[], int n) { int s, k; for(k = s = 0; k &lt; n; s += v[k++]); return s; </strong>\u0219i <strong>d) int suma(int v[], int n) { int s = 0; for(int k = n - 1; k &gt;= 0; k--) s += v[n - k - 1]; return s; }</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Func\u021bia <code>suma</code> prime\u0219te un tablou unidimensional <code>v</code> \u0219i un num\u0103r <code>n</code> de elemente \u0219i returneaz\u0103 suma elementelor acestuia.</li>\n<li>Algoritmul pentru calcularea sumei elementelor unui tablou unidimensional este de a parcurge elementele \u0219i de a le aduna \u00eentr-o variabil\u0103 auxiliar\u0103.</li>\n<li>Prin urmare, func\u021bia trebuie s\u0103 parcurg\u0103 elementele tabloului \u0219i s\u0103 le adune \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea a)</strong> <code>int suma(int v[], int n) { int s = 0, k = 0; while(k &lt; n) s += v[k++]; return s; }</code> este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea b)</strong> <code>int suma(int v[], int n) { int s = 0, k = 0; while(k++ &lt; n) s += v[k]; return s; }</code> este incorect\u0103 deoarece incrementeaz\u0103 <code>k</code> \u00eenainte de a aduna elementul la sum\u0103, ceea ce poate duce la erori.</li>\n<li><strong>Op\u021biunea c)</strong> <code>int suma(int v[], int n) { int s, k; for(k = s = 0; k &lt; n; s += v[k++]); return s; </code>este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code>.</li>\n<li><strong>Op\u021biunea d)</strong> <code>int suma(int v[], int n) { int s = 0; for(int k = n - 1; k &gt;= 0; k--) s += v[n - k - 1]; return s; }</code> este corect\u0103 deoarece parcurge elementele tabloului <code>v</code> \u0219i le adun\u0103 \u00een variabila <code>s</code> \u00een ordine invers\u0103.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint suma(int v[], int n) {\n    int s = 0, k = 0;\n    while(k &lt; n)\n        s += v[k++];\n    return s;\n}\n\nint main() {\n    int v[] = {1, 2, 3, 4, 5};\n    int n = 5;\n    printf(\"Suma elementelor: %d\\n\", suma(v, n));  // Afi\u0219eaz\u0103 suma elementelor\n    return 0;\n}\n</code></pre>"
  },
  {
    "id": 33,
    "question": "Funcția minmax primește prin parametrul de intrare v un tablou unidimensional format din numere întregi, iar prin parametrul de intrare n primește numărul de elemente ale tabloului v. Funcția trebuie să întoarcă prin doi parametri de ieșire, min și max, valoarea minimă și, respectiv, valoarea maximă din tabloul v. Care dintre următoarele variante reprezintă un antet corect al funcției minmax?",
    "answers": [
      "<div class=\"code_2\">void minmax(int v[],int n,int min,int max)</div>",
      "<div class=\"code_2\">int minmax(int v[],int n,int min,int max)</div>",
      "<div class=\"code_2\">void minmax(int v[],int n,int *min,int *max)</div>",
      "<div class=\"code_2\">void minmax(int *v[],int *n,int *min,int *max)</div>"
    ],
    "correctAnswerIndexes": [2]
  },
  {
    "id": 34,
    "question": "Fie v un tablou unidimensional format din 100 de numere reale de tip double și numărul natural k cuprins între 0 și 99. Care dintre următoarele expresii afișează adresa elementului v[k]?",
    "answers": [
      "<div class=\"code_2\">printf(\"%p\",v+k);</div>",
      "<div class=\"code_2\">printf(\"%p\",*(v+k));</div>",
      "<div class=\"code_2\">printf(\"%p\",v+k*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%p\",&v[k]);</div>"
    ],
    "correctAnswerIndexes": [0, 3]
  },
  {
    "id": 35,
    "question": "Fie 𝑣 un tablou unidimensional format din 100 de numere reale de tip double și 𝑝 o variabilă de tip pointer către double în care este memorată adresa ultimului element al tabloului 𝑣 (double *p=&v[99];). Care dintre următoarele expresii afișează numărul de octeți pe care<br>îi ocupă tabloul 𝑣 în memorie?",
    "answers": [
      "<div class=\"code_2\">printf(\"%d\",(p-v)*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%d\",100*sizeof(double));</div>",
      "<div class=\"code_2\">printf(\"%d\",p-v);</div>",
      "<div class=\"code_2\">printf(\"%d\",sizeof(v));</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 36,
    "question": "Care dintre următoarele secvențe de cod poate fi utilizată pentru a aloca dinamic un tablou unidimensional 𝑎 format din 100 de numere întregi?",
    "answers": [
      "<div class=\"code_2\">int *a = (int *)malloc(100*sizeof(int *));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(100*sizeof(int));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(100);</div>",
      "<div class=\"code_2\">int *a = (int *)calloc(100,sizeof(int));</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 37,
    "question": "Care dintre următoarele secvențe de cod poate fi utilizată pentru a aloca dinamic un tablou bidimensional 𝑎 format din 10 de linii și 20 de coloane de numere întregi?",
    "answers": [
      "<div class=\"code_2\">int **a = (int **)malloc(10*sizeof(int *));<br>for(int i=0;i&lt;10;i++)<br><span class=\"tab\"></span>a[i]=(int *)malloc(20*sizeof(int));</div>",
      "<div class=\"code_2\">int **a = (int **)calloc(10*sizeof(int *),20*sizeof(int));</div>",
      "<div class=\"code_2\">int *a = (int *)malloc(20*sizeof(int *));<br>for(int i=0;i&lt;20;i++)<br><span class=\"tab\"></span>a[i]=(int *)malloc(10*sizeof(int));</div>",
      "<div class=\"code_2\">int **a = (int **)calloc(10,sizeof(int*));<br>for(int i=0;i&lt;10;i++)<br><span class=\"tab\"></span>a[i]=(int *)calloc(20,sizeof(int));</div>"
    ],
    "correctAnswerIndexes": [0, 3]
  },
  {
    "id": 38,
    "question": "Fie 𝑎 un tabloul bidimensional pătratic de dimensiune 𝑛. Care dintre următoarele secvențe de cod afișează elementele aflate pe diagonala principală a matricei 𝑎?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i==j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][i]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i+j==n-1) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][n-i-1]);</div>"
    ],
    "correctAnswerIndexes": [0, 1]
  },
  {
    "id": 39,
    "question": "Fie 𝑎 un tabloul bidimensional pătratic de dimensiune 𝑛. Care dintre următoarele secvențe de cod afișează elementele aflate pe diagonala secundară a matricei 𝑎?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i==j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][i]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i+j==n-1) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) printf(\"%d \",a[i][n-i-1]);</div>"
    ],
    "correctAnswerIndexes": [2, 3]
  },
  {
    "id": 40,
    "question": "Fie 𝑎 un tabloul bidimensional pătratic de dimensiune 𝑛. Care dintre următoarele secvențe de cod afișează elementele triunghiului delimitat de prima coloană, diagonala principală și ultima linie din matricea 𝑎?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&gt;=j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&lt;=j) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;=i;j++) printf(\"%d \",a[i][j]);</div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=i;j&lt;n;j++) printf(\"%d \",a[i][j]);</div>"
    ],
    "correctAnswerIndexes": [0, 2]
  },
  {
    "id": 41,
    "question": "Fie 𝑎 un tabloul bidimensional pătratic de dimensiune 𝑛. Care dintre următoarele secvențe de cod afișează elementele triunghiului delimitat de diagonala principală, ultima coloană și ultima linie din matricea 𝑎?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&gt;=j) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++)<br><span class=\"tab_2\"></span>if(i&lt;=j) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=0;j&lt;=i;j++) printf(\"%d \",a[i][j]);",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++)<br><span class=\"tab\"></span>for(int j=i;j&lt;n;j++) printf(\"%d \",a[i][j]);"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 42,
    "question": "Fie 𝑎 un tabloul bidimensional pătratic de dimensiune 𝑛. Care dintre următoarele secvențe de cod afișează suma elementelor de pe fiecare linie a matricei 𝑎?",
    "answers": [
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) {<br><span class=\"tab_2\"></span>s=s+a[i][j];<br><span class=\"tab_2\"></span>printf(\"%d \",s);<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int s=0;<br>for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) {<br><span class=\"tab_2\"></span>s=s+a[i][j];<br><span class=\"tab_2\"></span>printf(\"%d \",s);<br><span class=\"tab\"></span>}<br>}</div>",
      "<div class=\"code_2\">int s=0;<br>for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) s=s+a[i][j];<br><span class=\"tab\"></span>printf(\"%d \",s);<br>}<br></div>",
      "<div class=\"code_2\">for(int i=0;i&lt;n;i++) {<br><span class=\"tab\"></span>int s=0;<br><span class=\"tab\"></span>for(int j=0;j&lt;n;j++) s=s+a[i][j];<br><span class=\"tab\"></span>printf(\"%d \",s);<br>}</div>"
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 43,
    "question": "Care dintre următoarele funcții returnează dimensiunea în octeți a unui fișier text a cărui cale<br>este transmisă prin parametrul de intrare 𝑛𝑓?",
    "answers": [
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>fseek(f,0,SEEK_END);<br><span class=\"tab\"></span>int n=ftell(f);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char c;<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(!feof(f)) {<br><span class=\"tab_2\"></span>fscanf(f,\"%c\",&c);<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n+1;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=sizeof(f);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fgets(s,1000,f))<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>"
    ],
    "correctAnswerIndexes": [0, 1]
  },
  {
    "id": 44,
    "question": "Care dintre următoarele funcții returnează numărul de linii dintr-un fișier text a cărui cale este transmisă prin parametrul de intrare 𝑛𝑓 (se presupune că fișierul nu conține linii vide)?",
    "answers": [
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fscanf(f,\"%s\",s)==1)<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char c;<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fscanf(f,\"%c\",&c)==1)<br><span class=\"tab_2\"></span>if(c=='\\n') n++;<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return n;<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=sizeof(f);<br><span class=\"tab\"></span>fclose (f);<br><span class=\"tab\"></span>return n/sizeof(char *);<br>}</div>",
      "<div class=\"code_2\">int nb(char *nf) {<br><span class=\"tab\"></span>char s[1001];<br><span class=\"tab\"></span>FILE *f=fopen(nf,\"r\");<br><span class=\"tab\"></span>int n=0;<br><span class=\"tab\"></span>while(fgets(s,1000,f))<br><span class=\"tab_2\"></span>n++;<br><span class=\"tab\"></span>fclose (f);<br><span class=\"tab\"></span>return n;<br>}</div>"
    ],
    "correctAnswerIndexes": [1, 3]
  },
  {
    "id": 45,
    "question": "Considerăm următorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>#include&lt;stdio.h&gt;<br>int main() {<br><span class=\"tab\"></span>FILE *f=fopen(\"test.txt\",\"r\");<br><span class=\"tab\"></span>char s[101],t[101];<br><span class=\"tab\"></span>while(fgets(s,100,f))<br><span class=\"tab_2\"></span>strcpy(t,s);<br><span class=\"tab\"></span>printf(\"%s\",t);<br><span class=\"tab\"></span>fclose(f);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Știind ca lungimea maximă a unei linii din fișierul text test.txt este de 100 de caractere, ce se va afișa după executarea programului de mai sus?",
    "answers": [
      "fiecare linie din fișier;",
      "penultima linie din fișier;",
      "ultimul caracter din fișier;",
      "ultima linie din fișier."
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 46,
    "question": "Considerăm următorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>#include&lt;stdio.h&gt;<br>int main() {<br><span class=\"tab\"></span>char s[21],aux[11];<br><span class=\"tab\"></span>strcpy(s,\"\");<br><span class=\"tab\"></span>for(int i=1;i&lt;=5;i++) {<br><span class=\"tab_2\"></span>printf(\"Sirul %d: \",i);<br><span class=\"tab_2\"></span>gets(aux);<br><span class=\"tab_2\"></span>…………………………………………………………<br><span class=\"tab\"></span>}<br><span class=\"tab\"></span>printf(\"%s\",s);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Presupunând că fiecare dintre cele 5 șiruri care vor fi citite de la tastatură vor fi formate din minim două caractere și maxim 10, stabiliți cu care dintre instrucțiunile de mai jos trebuie înlocuite spațiile punctate din program astfel încât acesta să afișeze șirul format din ultimele două caractere din fiecare dintre cele 5 șiruri citite:",
    "answers": [
      "<div class=\"code_2\">strcat(s,aux+9);</div>",
      "<div class=\"code_2\">strcat(s,aux[strlen(aux)-1]);</div>",
      "<div class=\"code_2\">strncat(s,aux,strlen(aux)-1);</div>",
      "<div class=\"code_2\">strcat(s,aux+strlen(aux)-2);</div>"
    ],
    "correctAnswerIndexes": [3]
  },
  {
    "id": 47,
    "question": "Care dintre următoarele secvențe de cod afișează pe ecran șirul de numere 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5?",
    "answers": [
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=5;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);",
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=i;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);",
      "<div class=\"code_2\">for(int i=1;i&lt;=5;i++)<br><span class=\"tab\"></span>for(int j=1;j&lt;=i;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",j);",
      "<div class=\"code_2\">for(int i=1;i&lt;=4;i++)<br><span class=\"tab\"></span>for(int j=i+1;j&lt;=5;j++)<br><span class=\"tab_2\"></span>printf(\"%d\",i);"
    ],
    "correctAnswerIndexes": [1]
  },
  {
    "id": 48,
    "question": "Stabiliți care dintre următoarele funcții întorc poziția primei valori strict pozitive din tabloul 𝑣 format din 𝑛 numere întregi sau -1 dacă tabloul nu conține nici un număr pozitiv:",
    "answers": [
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i,x=-1;<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if(v[i]&gt;0) x=i;<br><span class=\"tab\"></span>return x;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int x=0;<br><span class=\"tab\"></span>while(v[x]&lt;=0) x++;<br><span class=\"tab\"></span>return x-1;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i,x=-1;<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if((v[i]&gt;0)&&(x<0)) x=i;<br><span class=\"tab\"></span>return x;<br>}</div>",
      "<div class=\"code_2\">int p(int v[],int n) {<br><span class=\"tab\"></span>int i;<br><span class=\"tab\"></span>for(int i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>if (v[i]&gt;0) return i;<br><span class=\"tab\"></span>return -1;<br>}</div>"
    ],
    "correctAnswerIndexes": [2, 3]
  },
  {
    "id": 49,
    "question": "Considerăm următoarea secvență de cod:<br><br><div class=\"code\">int a, b, p=1;<br>scanf(\"%d %d\", &a, &b);<br>while(p &lt; a)<br><span class=\"tab\"></span>p = p*2;<br>while(p &lt;= b) {<br><span class=\"tab\"></span>printf(\"%d\", p);<br><span class=\"tab\"></span>p = p*2;<br>}</div><br><br>Dacă valorile introduse pentru variabilele a și b vor fi două numere naturale nenule cu proprietatea că a &lt; b, atunci pe ecran se vor afișa:",
    "answers": [
      "toate puterile lui 2 din intervalul [a,b];",
      "toate puterile lui 2 din intervalul (a,b];",
      "toate numerele pare din intervalul [a,b];",
      "toate numerele pare din intervalul (a,b];"
    ],
    "correctAnswerIndexes": [0]
  },
  {
    "id": 50,
    "question": "Considerăm următorul program:<br><br><div class=\"code\">#include&lt;stdio.h&gt;<br>void p(int v[],int *n) {<br><span class=\"tab\"></span>int i,j,g;<br><span class=\"tab\"></span>do {<br><span class=\"tab_2\"></span>g=0;<br><span class=\"tab_2\"></span>for(i=0;i&lt;*n;i++)<br><span class=\"tab_3\"></span>if(v[i]&lt;0) {<br><span class=\"tab_4\"></span>for(j=i;j&lt;*n-1;j++) v[j]=v[j+1];<br><span class=\"tab_4\"></span>(*n)--;<br><span class=\"tab_4\"></span>g=1;<br><span class=\"tab_3\"></span>}<br><span class=\"tab_2\"></span>}<br><span class=\"tab\"></span>while(g);<br>}<br><br>int main() {<br><span class=\"tab\"></span>int i,v[]={-1,2,-3,-4,5},n=5;<br><span class=\"tab\"></span>p(v,&n);<br><span class=\"tab\"></span>for(i=0;i&lt;n;i++)<br><span class=\"tab_2\"></span>printf(\"%d \",v[i]);<br><span class=\"tab\"></span>return 0;<br>}</div><br><br>Ce valori vor fi afișate pe ecran după executarea programului de mai sus?",
    "answers": ["–1 -3 -4", "2 5", "–1 2 -3 -4", "2 -3 -4 5"],
    "correctAnswerIndexes": [1],
    "details": "<p>R\u0103spuns corect: <strong>b) 2 5</strong></p>\n<p>Justificare:</p>\n<ul>\n<li>Programul de mai sus elimin\u0103 toate valorile negative din tabloul <code>v</code>. Func\u021bia <code>p</code> prime\u0219te un tablou de numere \u00eentregi <code>v</code> \u0219i un pointer <code>n</code> care reprezint\u0103 num\u0103rul de elemente din tablou.</li>\n<li><strong>Ini\u021bializarea \u0219i bucla <code>do-while</code></strong>: <code>do { g = 0; for (i = 0; i < *n; i++) { if (v[i] < 0) { for (j = i; j < *n - 1; j++) { v[j] = v[j + 1]; } (*n)--; g = 1; break; } } } while (g);</code> - <code>g</code> este un flag care indic\u0103 dac\u0103 a fost eliminat un element negativ. - Bucla <code>for</code> itereaz\u0103 prin toate elementele tabloului <code>v</code>. - Dac\u0103 un element <code>v[i]</code> este negativ, acesta este eliminat prin mutarea tuturor elementelor urm\u0103toare cu o pozi\u021bie spre st\u00e2nga. - Dimensiunea tabloului <code>n</code> este decrementat\u0103. - <code>g</code> este setat la 1 pentru a continua bucla <code>do-while</code>.</li>\n<li><strong>Apelarea func\u021biei <code>p</code> \u0219i afi\u0219area rezultatului</strong>: <code>p(v, &n); for (i = 0; i < n; i++) printf(\"%d \", v[i]);</code> - Func\u021bia <code>p</code> este apelat\u0103 pentru a elimina valorile negative din <code>v</code>. - Valorile r\u0103mase \u00een <code>v</code> sunt afi\u0219ate pe ecran.</li>\n<li>Programul va elimina toate valorile negative din tabloul <code>v</code>, l\u0103s\u00e2nd doar valorile <code>2</code> \u0219i <code>5</code>.</li>\n</ul>\n<p>Codul C pentru demonstra\u021bie:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid p(int v[], int *n) {\n    int i, j, g;\n    do {\n        g = 0;\n        for (i = 0; i < *n; i++) {\n            if (v[i] < 0) {\n                for (j = i; j < *n - 1; j++) {\n                    v[j] = v[j + 1];\n                }\n                (*n)--;\n                g = 1;\n                break;\n            }\n        }\n    } while (g);\n}\n\nint main() {\n    int i, v[] = { -1, 2, -3, -4, 5 }, n = 5;\n    p(v, &n);\n    for (i = 0; i < n; i++)\n        printf(\"%d \", v[i]);\n    return 0;\n}\n</code></pre>"
  }
]
